

# Relational Model Constraints and Relational Database Schemas

The state of the whole database corresponds to the states of all its relations at a particular point in time. There are generally many restrictions or constraints on the actual values in a database state. Constraints on databases can generally be divided into four main categories:

1. **Inherent model-based constraints (implicit constraints):** Constraints that are inherent in the data model.
    
2. **Schema-based constraints (explicit constraints):** Constraints that can be directly expressed in the schemas of the data model, typically by specifying them in the DDL.
    
3. **Application-based or semantic constraints (business rules):** Constraints that cannot be directly expressed in the schemas of the data model and must be enforced by application programs or other means.
    
4. **Data dependencies:** Constraints that are functional dependencies or multivalued dependencies.
    

### Domain Constraints

A domain constraint specifies that within each tuple, the value of each attribute **A** must be an atomic value from the domain **dom(A)**.

### Key Constraints and Constraints on NULL Values

A relation is defined as a set of tuples. All tuples in a relation must be distinct, meaning that no two tuples can have the same combination of values for all attributes.

- A **superkey (SK)** specifies a uniqueness constraint such that no two distinct tuples in any state of relation **R** can have the same value for **SK**.
    
- Every relation has at least one default superkey — the set of all its attributes.
    
- A **key (K)** of a relation schema **R** is a superkey with the additional property that removing any attribute **A** from **K** results in a set of attributes that is no longer a superkey.
    

A key satisfies two properties:

1. **Uniqueness:** Two distinct tuples in any state of the relation cannot have identical values for all attributes in the key. This also applies to a superkey.
    
2. **Minimality:** A key is a minimal superkey; no attributes can be removed while still preserving uniqueness.
    

A relation schema may have more than one key. In this case, each is called a **candidate key**. One of them is usually designated as the **primary key**, typically underlined when specifying the relation.

- A **superkey** is any set of attributes that uniquely identifies a tuple.
    
- A **candidate key** is a minimal superkey.
    

---

## 2.5 Relational Databases and Relational Database Schemas

A **relational database schema (S)** is a set of relation schemas:  
**S = {R1, R2, R3, ..., Rm}**  
and a set of integrity constraints **IC**.

A **relational database state (DB)** of **S** is a set of relation states:  
**DB = {r1, r2, ..., rm}**  
such that each **ri** is a state of **Ri** and satisfies the integrity constraints specified in **IC**.

- A database state that **does not satisfy all constraints** is called **not valid**.
    
- A database state that **does satisfy all constraints** is called a **valid state**.
    

Integrity constraints are defined on the database schema and must hold on every valid state.

---

## 2.6 Entity Integrity, Referential Integrity, and Foreign Keys

### Entity Integrity

- No **primary key** value can be **NULL**.
    

### Referential Integrity

A referential integrity constraint is specified between two relations to maintain consistency among tuples.

A set of attributes **FK** in relation schema **R1** is a **foreign key** referencing relation **R2** if:

1. The attributes in **FK** have the same domain(s) as the primary key attributes **PK** of **R2**.
    
2. For any tuple **t1** in the current state of **R1**, the value of **FK** either:
    
    - Occurs as the value of **PK** in some tuple **t2** in **R2**, or
        
    - Is **NULL**.
        

- **R1** is called the referencing relation.
    
- **R2** is the referenced relation.
    
- A foreign key can refer to the same relation it belongs to (self-referencing).
    

---

## 2.7 Other Types of Constraints

- **Semantic integrity constraints:** e.g., the salary of an employee should never be more than their supervisor’s. Enforced using triggers or assertions.
    
- **State constraints:** The database state must always be valid.
    
- **Transition constraints:** e.g., the salary of an employee can only increase.
    

---

# Update Operations, Transactions, and Dealing with Constraint Violations

### Operations of the Relational Model:

- **Retrievals:** Queries that return new relations by applying relational operators.
    
- **Updates:** Modify the state of relations using:
    
    - **Insert:** Adds new tuples.
        
    - **Delete:** Removes existing tuples.
        
    - **Update (Modify):** Changes attribute values in existing tuples.
        

All operations must respect integrity constraints.

---

## 2.8.1 The Insert Operation

Provides attribute values for a new tuple **t** in relation **R**. Insert can violate:

- **Domain constraint:** If an attribute value does not match its domain.
    
- **Key constraint:** If the key value already exists.
    
- **Entity integrity:** If a primary key value is **NULL**.
    
- **Referential integrity:** If a foreign key value refers to a non-existent tuple.
    

---

## 2.8.2 The Delete Operation

Can violate **referential integrity** if the deleted tuple is referenced by foreign keys. Possible options when this happens:

- **Restrict**
    
- **Cascade**
    
- **Set null / Set default**
    

---

## 2.8.3 The Update Operation

Used to modify attribute values in one or more tuples of a relation **R**.

- Must specify a **condition** to identify tuples to update.
    
- Must ensure **no integrity constraints are violated**.

	