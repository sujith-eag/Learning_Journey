

Use React to define a <Captcha /> or
<DatePicker /> component that you can add to your form: a simple drop-in component with all the functionality and logic to communicate with the backend.


Creating composable UIs has been around for a long
time, but React is the first to use pure JavaScript without templates to make this possible. And this approach has proven easier to maintain, reuse, and extend.

React is a great library for building UIs, and it should be part of your frontend web toolkit, but it isn’t a complete solution for all frontend web development.


source code for the example in this chapter is available at https://rq2e.com/ch01.


### Benefits of Using React


* Simpler web apps—React uses a component-based architecture (CBA) with pure JavaScript; a declarative style; and powerful, developer-friendly Document Object Model (DOM) abstractions (and not just DOM, but also iOS, Android, etc.).

* Fast UIs—React provides outstanding performance thanks to its virtual DOM and smart reconciliation algorithm, which, as a side benefit, lets you perform testing without spinning up (starting) a headless browser.

* Less code to write—React’s great community and vast ecosystem of components provide developers with a variety of libraries and components. This is important when you’re considering what framework to use for development.

Simplicity is achieved through
* Declarative over imperative style—React embraces declarative style over imperative by updating views automatically.
* CBA using pure JavaScript—React doesn’t use domain-specific languages (DSLs) for its components, just pure JavaScript. And there’s no separation when working on the same functionality.
* Powerful abstractions—React has a simplified way of interacting with the DOM, allowing you to normalize event handling and other interfaces that work similarly across browsers.

___

#### Declarative over Imperative Style

Declarative style means developers write how it should be, not what to do, step by step (imperative).

* Statements versus expressions—Imperative-style programming often works with independent statements that individually advance the program state, while declarative programming uses expressions that build upon each other to progress the flow of logic.
* Reserved word usage—Imperative-style programming often uses many reserved words such as for, while, switch, if, and else, while declarative-style programming uses array methods, arrow functions, object access, Boolean expressions, and ternary operators to achieve the same results.
* Function composition —Imperative-style programming often uses independent function calls and method invocations, while declarative-style programming uses function composition to build upon the previous expression and make small generalized pieces of logic that, when composed, achieve the desired result.
* Mutability—Imperative-style programming often uses mutable objects and manipulates existing structures, while declarative-style programming uses immutable data and creates new structures from old ones rather than editing existing ones.

___

countGoodPasswords, that, given a list of passwords, will return how many of the passwords are good. Here, we’ll define a good password as any pass-
word at least nine characters long.

```js
function countGoodPasswords(passwords)
{
	const goodPasswords = [];
	
	for(let i = 0; i< passwords.length; i++)
	{
		const password = passwords[i];
		
		if(password.length < 9)
		{
			continue;
		}
		goodPasswords.push(password);
	}
	return goodPasswords.length;
}
```
Here new statements change the program state `const, push`, existing objects are mutated, reserved words control the program flow.

In a declarative programming paradigm
```js
function countGoodPasswords(passwords) {
	return passwords.filter(p => p.length >= 9).length;
}
```

We arrive directly at the goal in a single statement by manipulating an object in several steps, using function composition to arrive at the target.


___

React takes the same declarative approach when you compose UIs. First, React developers describe UI elements in a declarative style. Then, when there are changes to views generated by those UI elements, React takes care of the updates.

The convenience of React’s declarative style fully shines when you need to make changes to the view. Those are called changes of the internal state. When the state changes, React updates the view accordingly.


___

#### Component Based Architecture Using Pure JavaScript

Separation of concerns, loose coupling, and code reuse are at the heart of this approach

What was lacking before React was a pure JavaScript implementation of this architecture. When you’re working with Angular, Backbone, Ember, or most of the other Model-View-Controller (MVC)-like frontend frameworks, you have one file for JavaScript and another for the template. (Angular uses the term directives for components.)

For developers, it makes more sense not to require separation of HTML and Java-Script when working on a piece of a project (component).


Under the hood, React uses a virtual DOM to find differences (the delta) between what’s already in the browser and the new view. This process is called DOM diffing or reconciliation of state and view (bringing them back to similarity). This means developers don’t need to worry about explicitly changing the view; all they need to do is update the state, and the view will be updated automatically as needed.

We never do DOM manipulation directly; we let React do that work for us.

___

#### Powerful Abstractions

React comes with the following great abstractions that make life as a React developer
easier:
* Synthetic events abstracting out browser differences in native events
* JavaScript XML (JSX) abstracting out the JS DOM
* Browser independence allowing rendering in nonbrowser environments (e.g., on the server)


when you create an onClick event in React, instead of the event handler receiving a native browser–specific event object, it receives a synthetic event object that’s a wrapper around native event objects. You can expect the same behavior from synthetic events regardless of the browser in which you run the code. React also has a set of synthetic events for touch events, which are great for building web apps for mobile devices.


JSX, which is one of the more controversial elements of React. For some, the abstraction of JSX is a strong argument for using React, while JSX has been a stumbling block or even a deterrent for others.


JSX is a bit of syntactic sugar on top of JavaScript for writing React elements in JavaScript using HTML-like notation with <>. 
JSX as a mini-language that’s compiled into native JavaScript. So, JSX isn’t run on the browser but is used as the source code for compilation.

> [!note]
JSX is optional


```js
if (user.session)
{
	return <a href="/logout" >Logout</a>;
}
else
{
	return <a href="/login">Login</a>;
}
```

Another example of React’s DOM abstraction is that you can render React elements on the server. This can be handy for better search engine optimization (SEO) and improving performance.

You can even use hybrid approaches where
your templates are rendered with some content on the server and later rehydrated
with live data in the browser.

#### Speed and Testability

React’s virtual DOM exists only in the JavaScript memory.
Every time there’s a data change, React first compares the differences using its virtual DOM; only when the library knows there has been a change in the rendering will it update the actual DOM.

React updates only those parts that are necessary so that the internal state (virtual DOM) and the view (real DOM) are the same.

if there’s a `<p>` element, and you augment the text via the state of the component, only the text will be updated (i.e., innerHTML), not the element itself. 

This results in increased performance compared to re-rendering entire sets of elements or, even more so, entire pages (server-side rendering).


### Disadvantages of React

* React isn’t a full-blown, Swiss Army knife–type of framework. Developers need to pair it with a library such as Redux or XState to achieve functionality comparable to Angular or Ember.
* React stacks require maintenance and continuous package management. Because you never use React only on its own, but almost always combine it with several other packages, you need to constantly maintain your dependencies and make sure you’re using the correct versions of various packages. In larger projects, this can become a significant source of extraneous tasks.
* React uses a somewhat new approach to web development, and JSX and functional programming can be intimidating to beginners.
* React only has a one-way binding. Although one-way binding is better for complex web apps and removes a lot of complexity.
* React isn’t reactive (as in reactive programming and architecture, which are more event-driven, resilient, and responsive) out of the box. Developers need to use other libraries, such as the React Query library, to make their applications integrate with external content seamlessly and responsively.

___

### Fitting react into Website

The React core library is a UI library first and foremost. The core library alone is comparable to other UI libraries, but not directly comparable to more full-fledged web application frameworks such as Angular.

It’s very difficult and bordering on impossible
to create a hybrid SPA with some parts rendered by, for example, Angular or Vu, and others by React.

You can use React for just part of your UI if you have a website with smaller interactive UI elements (or widgets). In such a case, you can replace your widgets one by one with small React applications, without changing everything else.

React is backend agnostic for frontend development. In other words, you don’t have to rely on a JavaScript-based backend (Node or Deno) to use React.


___

Another popular use case for React is for static site generators. In such a setup,
React is used to define your website locally on your environment, but when deployed
to the live server, it’s rendered “down” to a plain HTML website with JavaScript only
doing a minimal bit of work to add interactivity. All your templates, and so on, will
have been resolved. Initially, this was mostly popular for smaller websites, such as
blogs, which don’t update too frequently.

___

To summarize how React fits into a website, it’s most often used in these scenarios:
* As a UI library in an SPA, such as React+React Router+Redux
* As a drop-in widget in any frontend stack, such as a React autocomplete input component in a website built using any other combination of technologies
* As a static website rendered on deployment to serve infrequently updated content
* As a UI library in mobile apps using React Native, or desktop apps using Electron

### Single-page applications and React

A website is considered an SPA if it has a lot of
functionality directly available in the browser and not just information. 

Examples include Facebook, Google Docs, Gmail, and so on.

SPAs are built using a multitude of technologies, of which React is only one potential part in the stack. You can’t even use React alone; at least a few other technologies are needed for React to be usable as a standalone application.

SPAs are also known as thick clients because the browser, being a client, holds more logic and performs functions such as rendering of the HTML, validation, UI changes, and so on. Contrast this with a thin client, where the browser client is only used to display information that has been pre-rendered by a server. In a thin client, the browser does very little work.

* The user types a URL in the browser to open a new page. 
* The browser sends a URL request to the server.
* The server responds with static assets such as HTML, CSS, and JavaScript. In most cases, the HTML is bare-bones; that is, it has only a skeleton of the web page. Usually, there’s a “Loading . . . ” message and/or rotating spinner GIF.
* The static assets include the JavaScript code for the application. When loaded, this code makes additional requests for data.
* The data comes back in JSON, XML, or any other format.
* Once the application receives the data, it can render missing HTML (the User Interface block in the figure). 
* Once the browser rendering is finished, the browser updates the displayed content, and the user can work with the application.
* The user sees a beautiful web page.

> [!hydaration]
> The process of rendering the UI occurs within the browser as the application injects data into pre-rendered templates, also known as hydration.


To summarize, in an SPA, most rendering for UIs happens in the browser. Only data travels to and from the browser. Contrast that with a “classic” website, which is not an SPA, where all the rendering happens on the server.

React fits into this SPA architecture by rendering content based on data as well as handling user input and updating the content based on the updated data that results from these inputs.


___

### The React Stack

React is minimalistic in
the sense that it only does a single job rendering reactive UIs.

While you can use React as a smaller part of your stack, developers most often opt to use a React-centric stack, which consists of the React core itself as well as data, routing, and styling libraries created to be used specifically with React,

* Data model libraries and backends—Examples include TanStack Query (https://tanstack.com/query/latest), Redux (http://redux.js.org), Recoil.js (https://recoiljs.org/), XState (https://xstate.js.org/), and Apollo (www.apollographql.com/)


* Routing library—Often React Router (https://github.com/remix-run/react-router) or a similar router implemented in many frameworks

* Styling libraries—Either a predefined set of styled components such as Material UI (https://mui.com/) or Bootstrap (https://react-bootstrap.github.io/) or a library to easily work with CSS inside React components, such as Styled-Components (https://styled-components.com/), Vanilla Extract (https://vanilla-extract.style/), or even Tailwind CSS (https://tailwindcss.com/)


React’s ability to describe composable components (self-contained chunks of the UI) enables code reuse. Many components are packaged as npm modules.

A great (curated) list of a lot of various React components for many purposes can be found here: https://github.com/brillout/awesome-react-components. This list has everything from UI components (including tons of form elements) to complete UI frameworks to development utilities and testing tools.


___

Another category of React frameworks is the full-blown server-side framework, which
takes care of everything for you. Such frameworks come in two variants

* Gatsby—This very popular blogging framework is also useful for many other types of static websites.
* Next.js—As probably the most popular React website framework out there, this is useful for both small static websites and huge dynamic behemoths.
* Remix—This fairly new kid on the block is gaining traction and popularity very quickly in serving super-fast dynamic React websites.

___

JSX is optional 

Although all React developers write React using JSX, browsers will only run standard JavaScript and not understand JSX directly. That’s why it’s beneficial to be able to understand React code in pure JavaScript.

```html
<!DOCTYPE html>
<html>
	<head>
		<title>My First React Application</title>
		<script src="//unpkg.com/react@18/umd/react.development.js">
		 </script>

		<script src="//unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
	</head>

	<body>
		<div id="root"></div>
		
		<script type="text/javascript">
			...
		</script>
	</body>
</html>
```

First two scrips are importing React library and ReactDOM library.

Div element is used to mount the React UI. Mounting to the body directlt will lead to conflict with other libraries and extensions.

By including the libraries in the HTML file, you get access to the React and React-DOM global objects: `window.React` and `window.ReactDOM`.
You’ll need two methods from those objects: one to create an element and another to render it in the
`<div>` container.


#### Creating the React Element

The java Script part will contain
```js
const reactElement = React.createElement(
	'h1', null, 'Hello world!!' );

const domNode = document.getElementById('root');
const root = ReactDOM.createRoot(domNode);
root.render(reactElement);
```


Call `React.createElement(elementName, data, children)` with three arguments that have the following meanings:
* elementName—HTML tag as a string (e.g., 'h1') or a custom component class as an object. We don’t have any custom components just yet.
* data—A data object containing attributes and properties for the element. We don’t need any properties now, so we just pass null.
* children—Child elements or inner HTML/text content. In this example, it’s just “Hello world!!!”.

This listing gets a React element and stores the reference to this object in the reactElement variable. The reactElement variable isn’t an actual DOM node; rather, it’s an instantiation of the React h1 component (element).


Then get the DOM element with ID 'root', 

`const root = ReactDOM.createRoot(domNode);`
Creates a root holder for the React application connected to the specific DOM element.

`root.render(reactElement);` renders the h1 element into the root holder.

___

More consice version
```js
ReactDOM
.createRoot(document.getElementById('root'))
.render(React.createElement('h1', null, 'Hello world!'));
```


we need to serve the content using a local development web server.

