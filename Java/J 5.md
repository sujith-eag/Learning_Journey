
## Chapter 3 : Program Control Statements

Key Skills & Concepts
●Input characters from the keyboard
●Know the complete form of the if statement
●Use the switch statement
●Know the complete form of the for loop
●Use the while loop
●Use the do-while loop
●Use break to exit a loop
●Use break as a form of goto
●Apply continue
●Nest loops

____

### Input Characters from the Keyboard

To read a character from the keyboard, we will use `System.in.read( )`

The `read()` method waits until the user presses a key and then returns the result.

The character is returned as an
integer, so it must be cast into a char to assign it to a char variable.

By default, console input
is line buffered. Here, the term buffer refers to a small portion of memory that is used to hold
the characters before they are read by your program.

```java
class KbIn 
{
	public static void main(String[] args)
		throws java.io.IOException 
		{
			char ch;
			System.out.print("Press a key followed by Enter: ");
			ch = (char) System.in.read();
			
			System.out.println("Your key is: " + ch);
		}
}
```

```
Press a key followed by ENTER: t
Your key is: t
```

___

Main begins like this
```
public static void main(String[] args)
throws java.io.IOException {
```
because when `System.in.read()` is used, the program must specify the `throws java.io.IOException` clause to handle input errors.

The fact that System.in is line buffered is a source of annoyance at times. When you
press ENTER, a carriage return, line feed sequence is entered into the input stream. Furthermore,
these characters are left pending in the input buffer until you read them. Thus, for some
applications, you may need to remove them (by reading them) before the next input operation.


___


#### The if Statement

```
f(condition)
{
	statement sequence
}
else
{
	statement sequence
}
```

```java
// Guess the letter game.

class Guess 
{
	public static void main(String[] args)
	throws java.io.IOException 
	{
		char ch, answer = 'K';
		System.out.println("I'm thinking of a letter between A and Z.");
		System.out.print("Can you guess it: ");
		ch = (char) System.in.read(); // read a char from the keyboard
		if(ch == answer) System.out.println("** Right **");

		else System.out.println("...Sorry, you're wrong.");
	}
}
```

#### If else if ladder

```java
if(condition)
	statement;
else if(condition)
	statement;
else if(condition)
	statement;
.
.
.
else
	statement;
```

The conditional expressions are evaluated from the top downward. As soon as a true condition
is found, the statement associated with it is executed, and the rest of the ladder is bypassed. If
none of the conditions are true, the final else statement will be executed.

___

#### Switch Statement

Beginning with JDK 14, the
switch has been significantly enhanced and expanded with several new features that go
far beyond its original capabilities.

The second of Java’s selection statements is the switch. The switch provides for a multiway
branch. Thus, it enables a program to select among several alternatives. Although a series
of nested if statements can perform multiway tests, for many situations the switch is a more
efficient approach.

The traditional switch works like this: the value of
an expression is successively tested against a list of constants. When a match is found, the
statement sequence associated with that match is executed.

```
switch(expression) 
{
	case constant1:
		statement sequence
		break;
	case constant2:
		statement sequence
		break;
	case constant3:
		statement sequence
		break;
.
.
.
	default:
		statement sequence
}
```

For versions of Java prior to JDK 7, the expression controlling the switch must resolve to
type byte, short, int, char, or an enumeration.

today, expression can also be of type String.

Duplicate case values are not allowed. The type of each value must be compatible
with the type of expression.
The default statement sequence is executed if no case constant matches the expression.
The default is optional;

```java
// Demonstrate the switch.
class SwitchDemo 
{
	public static void main(String[] args) 
	{
		int i;
		for(i=0; i<10; i++)
			switch(i) 
			{
				case 0:
					System.out.println("i is zero");
					break;
				case 1:
					System.out.println("i is one");
					break;
				case 2:
					System.out.println("i is two");
					break;
				case 3:
					System.out.println("i is three");
					break;
				case 4:
					System.out.println("i is four");
					break;
				default:
					System.out.println("i is five or more");
				}
	}
}
```

`switch(i)` is given as a single line of code in the `for` loop but switch has its own block.


execution will continue into the next case if no break statement is present.

You can have empty cases,

___

#### for loop

```
for(initialization; condition; iteration)
{
	statement sequence
}
```

```java
// Show square roots of 1 to 99 and the rounding error.

class SqrRoot 
{
	public static void main(String[] args) 
	{
		double num, sroot, rerr;
		for(num = 1.0; num < 100.0; num++) 
		{
			sroot = Math.sqrt(num);
			System.out.println("Square root of " + num + " is " + sroot);
			// compute rounding error
			rerr = num - (sroot * sroot);
			System.out.println("Rounding error is " + rerr);
			System.out.println();
		}
	}
}
```

rounding error is computed by squaring the square root of each number. This result is then subtracted from the original number, thus yielding the rounding error.

```java
// A negatively running for loop.

class DecrFor 
{
	public static void main(String[] args) 
	{
		int x;
		for(x = 100; x > -100; x -= 5)
			System.out.println(x);
	}
}
```

multiple loop control variables can be used
```java
// Use commas in a for statement.

class Comma 
{
	public static void main(String[] args) 
	{
		int i, j;
		for(i=0, j=10; i < j; i++, j--)
			System.out.println("i and j: " + i + " " + j);
	}
}
```

```
The output from the program is shown here:
i and j: 0 10
i and j: 1 9
i and j: 2 8
i and j: 3 7
i and j: 4 6
```

____

#### for loop variations

The condition controlling the loop can be any valid Boolean expression. It does not need
to involve the loop control variable. In the next example, the loop continues to execute until
the user types the letter S at the keyboard:

```java
// Loop until an S is typed.

class ForTest 
{
	public static void main(String[] args)
	throws java.io.IOException 
	{
		int i;
		System.out.println("Press S to stop.");
		for(i = 0; (char) System.in.read() != 'S'; i++)
			System.out.println("Pass #" + i);
	}
}
```

___

#### Missing Pieces

In Java, it is possible for any or all of the initialization, condition, or iteration portions of the
for loop to be blank.

```java
// Parts of the for can be empty.
class Empty 
{
	public static void main(String[] args) 
	{
		int i;
		for(i = 0; i < 10; ) 
		{
			System.out.println("Pass #" + i);
			i++; // increment loop control var
		}
	}
}
```
The loop control variable i is incremented inside the body of the loop.
```
Pass #0
Pass #1
Pass #2
Pass #3
Pass #4
Pass #5
.....
```
Moving initialization out of for
```java
class Empty2
{
	public static void main(String[] args)
	{
		int i;
		i = 0;
		for( ; i<10; )
		{
			System.out.println("Pass #" + i);
			i++;
		}
	}
}
```


Placing the initialization
outside of the loop is generally done only when the initial value is derived through a complex
process that does not lend itself to containment inside the for statement.


___

#### The Infinite Loop

```
for(;;) // intentionally infinite loop
{
	//...
}
```

most “infinite loops” are really just
loops with special termination requirements. and breaking out using break.

___

#### Loop with No body

In Java, the body associated with a for loop (or any other loop) can be empty. This is because a
null statement is syntactically valid.

```java
class Empty3
{
	public static void main(String[] args)
	{
		int i;
		int sum = 0;
		
		// sum numbers through 5
		for(i = 1; i<=5; sum += i++)  ; // No body
		System.out.println("Sum is " + sum );
	}
}

// Sum is 15
```

`sum += i++` Add to sum the value of sum plus i, then increment i.

same as `sum = sum + i;  i++;`

If the loop control variable is not needed outside the loop then it can be declared in the for only


___

Enhanced for loops provide a way to cycle through the contents of a collection of objects like arrays.

___



### while Loop

`while(condition) statement;`

where statement may be a single statement or a block of statements, and condition defines the
condition that controls the loop. The condition may be any valid Boolean expression. The loop
repeats while the condition is true. When the condition becomes false, program control passes
to the line immediately following the loop.

```java
// Demonstrate the while loop.
class WhileDemo 
{
	public static void main(String[] args) 
	{
		char ch;
		// print the alphabet using a while loop
		ch = 'a';
		while(ch <= 'z') 
		{
			System.out.print(ch);
			ch++;
		}
	}
}
```

```java
// Compute integer powers of 2.

class Power 
{
	public static void main(String[] args) 
	{
		int e;
		int result;
		for(int i=0; i < 10; i++) 
		{
			result = 1;
			e = i;
			while(e > 0) 
			{
				result *= 2;
				e--;
			}
			System.out.println("2 to the " + i + " power is " + result);
		}
	}
}
```


___

#### do-while loop

The last of Java’s loops is the do-while. The do-while loop checks its condition at the bottom of the loop. This means that a do-while loop will always execute at least once.
```
do 
{
	statements;
} while(condition);
```

```java
// Demonstrate the do-while loop.

class DWDemo 
{
	public static void main(String[] args)
		throws java.io.IOException 
		{
			char ch;
			do 
			{
				System.out.print("Press a key followed by ENTER: ");
				ch = (char) System.in.read(); // get a char
			} while(ch != 'q');
		}
}
```

Guessing Game
```java
class Guess 
{
	public static void main(String[] args)
		throws java.io.IOException
	{
		char ch, ignore, answer = 'K';
		
		do
		{
			System.out.println("I'm thinking of a letter.");
			System.out.print("Can you guess it: ");
			
			ch = (char) System.in.read();
			
			do
			{
				ignore = (char) System.in.read();
			} while( ignore != '\n');
			
			if(ch == answer)
				System.out.println("** Right **");
			else 
			{
				System.out.print("..Sorry, you're ");
				if(ch < answer)
					System.out.println("too low");
				else
					System.out.println("too high");
				System.out.println("Try again! \n");
			}
		} while(answer != ch);
	}
}
```

```
I'm thinking of a letter.
Can you guess it: A
...Sorry, you're too low
Try again!

I'm thinking of a letter.
Can you guess it: Z
...Sorry, you're too high
Try again!

I'm thinking of a letter.
Can you guess it: K
** Right **
```

There are two do-while loops in the
program. The first loops until the user guesses the letter.


```java
// discard any other characters in the input buffer
do 
{
	ignore = (char) System.in.read();
} while(ignore != '\n');
```
console input is line buffered—you have to press ENTER before characters are
sent. Pressing ENTER causes a carriage return and a line feed (newline) sequence to be generated.
These characters are left pending in the input buffer. Also, if you typed more than one key before
pressing ENTER, they too would still be in the input buffer. This loop discards those characters by
continuing to read input until the end of the line is reached. If they were not discarded, then those
characters would also be sent to the program as guesses, which is not what is wanted.

after you have learned more about Java, some other, higher-level ways of handling console input are described.

____

#### break to Exit a loop

```java
// Using break to exit a loop.

class BreakDemo 
{
	public static void main(String[] args) {
int num;
num = 100;
// loop while i-squared is less than num
for(int i=0; i < num; i++) {
if(i*i >= num) break; // terminate loop if i*i >= 100
System.out.print(i + " ");
}
		System.out.println("Loop complete.");
	}
}
```

```
0 1 2 3 4 5 6 7 8 9 Loop complete.
```

____

```java
class Break1
{
	public static void main(String[] args)
		throws java.io.IOException
	{
		char ch;
		for( ; ; )
		{
			ch = (char) System.in.read();
			if(ch == 'q') 
				break;
		}
		System.out.println("You pressed q!");
	}
}
```


Using break in Nested loops
```java
class Break2
{
	public static void main(String[] args)
	{
		for(int i=0; i<3; i++)
		{
			System.out.println("Outer loop count: " + i);
			System.out.print("    Inner loop count: ");
		
			int t = 0;
			while(t<100)
			{
				if(t==10) break;
				
				System.out.print(t + " ");
				t++;
			}
			System.out.println();
		}
		System.out.println("Loops complete.");
	}
}
```

```
Outer loop count: 0
	Inner loop count: 0 1 2 3 4 5 6 7 8 9
Outer loop count: 1
	Inner loop count: 0 1 2 3 4 5 6 7 8 9
Outer loop count: 2
	Inner loop count: 0 1 2 3 4 5 6 7 8 9
Loops complete.
```

____

#### use break as a form of goto

Java does not have a goto statement, because it provides an unstructured way to alter the flow of program execution.

In addition to its uses with the switch statement and loops, the break statement can be employed by itself to provide a “civilized” form of the goto statement.



The general form of the labeled break statement is shown here: `break label;`

Typically, label is the name of a label that identifies a block of code. When this form of break
executes, control is transferred out of the named block of code. The labeled block of code must
enclose the break statement, but it does not need to be the immediately enclosing block. This
means that you can use a labeled break statement to exit from a set of nested blocks.

These blocks need not
be part of a loop or a switch. They can be any block. Further, you can specify precisely where
execution will resume, because this form of break works with a label.


To name a block, put a label at the start of it. The block being labeled can be a stand-alone
block, or a statement that has a block as its target. A label is any valid Java identifier followed
by a colon. Once you have labeled a block, you can then use this label as the target of a break
statement. Doing so causes execution to resume at the end of the labeled block. 


```java
// Using break with a label

class Break3
{
	public static void main(String[] args)
	{
		int i;
		for(i=1; i<4; i++)
		{
			one:{
				two:{
					three:{
						System.out.println("\ni is " + i);
						if(i==1) break one;
						if(i==2) break two;
						if(i==3) break three;
						
						// this is never reached
						System.out.println("This never print");
					}
					System.out.println("After block three");		
				}
				System.out.println("After block two");
			}
			System.out.println("After block one");
		}
		System.out.println("After for loop");
	}
}
```

```
i is 1
After block one

i is 2
After block two
After block one

i is 3
After block three
After block two
After block one
After for loop
```


____

```java
// Another example of using break with a label.
class Break5 {
	public static void main(String[] args) {
	done:
		for(int i=0; i<10; i++) {
			for(int j=0; j<10; j++) {
				for(int k=0; k<10; k++) {
					System.out.println(k + " ");
					if(k == 5) break done; // jump to done
					}
					System.out.println("After k loop"); // won't execute
				}
				System.out.println("After j loop"); // won't execute
			}
			System.out.println("After i loop");
	}
}
```

```
0
1
2
3
4
5
After i loop
```

___


```java
// label before for statement

stop1: for(x=0; x < 5; x++) {
	for(y = 0; y < 5; y++) {
		if(y == 2) 
			break stop1;
		System.out.println("x and y: " + x + " " + y);
	}
}
```
when the break executes, it transfers control to
the end of the entire for block, skipping the rest of the outer loop’s iterations.

```java
// now, put label immediately before {

for(x=0; x < 5; x++)
stop2: {
		for(y = 0; y < 5; y++) 
		{
			if(y == 2) break stop2;
			System.out.println("x and y: " + x + " " + y);
		}
	}
```
when break stop2 executes,
control is transferred to the end of the outer for’s block, causing the next iteration to occur.


_____


#### continue

The continue statement forces the next iteration of
the loop to take place, skipping any code between itself and the conditional expression that
controls the loop. Thus, continue is essentially the complement of break.

```java
class ContDemo 
{
	public static void main(String[] args)
	{
		int i;
		
		for(i=0; i<=100; i++)
		{
			if( (i%2) != 0)
				continue;
			System.out.println(i);
		} // Printing even numbers
	}
}
```

___

As with the break statement, continue may specify a label to describe which enclosing
loop to continue. Here is an example program that uses continue with a label:
```java
// Use continue with a label.
class ContToLabel {
	public static void main(String[] args) {
	
	outerloop:
		for(int i=1; i < 10; i++) {
			System.out.print("\nOuter loop pass " + i + ", Inner loop: ");

			for(int j = 1; j < 10; j++) {
				if(j == 5) continue outerloop; // continue outer loop
				System.out.print(j);
			}
		}
	}
}
```
when the continue executes, control passes to the outer loop, skipping the remainder of the inner loop.
```
Outer loop pass 1, Inner loop: 1234
Outer loop pass 2, Inner loop: 1234
Outer loop pass 3, Inner loop: 1234
Outer loop pass 4, Inner loop: 1234
Outer loop pass 5, Inner loop: 1234
Outer loop pass 6, Inner loop: 1234
Outer loop pass 7, Inner loop: 1234
Outer loop pass 8, Inner loop: 1234
Outer loop pass 9, Inner loop: 1234
```

___

#### Nested Loops

find the factors of the numbers from 2 to 100:

```java
class FindFac
{
	public static void main(String[] args)
	{
		for(int i=2; i<=100; i++)
		{
			System.out.print("Factors of " + ": ");
			for(int j=2; j<i; j++)
				if( (i%j)==0)
					System.out.print(j + " ");
				System.out.println();
		}
	}
}
```

```
Factors of 2:
Factors of 3:
Factors of 4: 2
Factors of 5:
Factors of 6: 2 3
Factors of 7:
Factors of 8: 2 4
Factors of 9: 3
Factors of 10: 2 5
Factors of 11:
Factors of 12: 2 3 4 6
....
```
