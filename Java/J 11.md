
## Chapter 9 : Exception Handling

Key Skills & Concepts
●Know the exception hierarchy
●Use try and catch
●Understand the effects of an uncaught exception
●Use multiple catch statements
●Catch subclass exceptions
●Nest try blocks
●Throw an exception
●Know the members of Throwable
●Use finally
●Use throws
●Know Java’s built-in exceptions
●Create custom exception classes


An exception is an error that occurs at run time.
Using Java’s exception handling subsystem you can, in a structured and controlled manner,
handle run-time errors.

___


#### Exception Hierarchy

In Java, all exceptions are represented by classes. 

All exception classes are derived from a class
called Throwable. Thus, when an exception occurs in a program, an object of some type of
exception class is generated. 

There are two direct subclasses of Throwable: Exception and Error. 

Exceptions of type Error are related to errors that occur in the Java Virtual Machine itself, and not in your program. These types of exceptions are beyond your control, and your program will not usually deal with them. Thus, these types of exceptions are not described here.


Errors that result from program activity are represented by subclasses of Exception.
For example, divide-by-zero, array boundary, and file errors fall into this category. In general,
your program should handle exceptions of these types. An important subclass of Exception is
RuntimeException, which is used to represent various common types of run-time errors.


Exceptions are generated in three different ways. First, the Java Virtual Machine can
generate an exception in response to some internal error which is beyond your control.
Normally, your program won’t handle these types of exceptions. Second, standard
exceptions, such as those corresponding to divide-by-zero or array index out-of-bounds, are
generated by errors in program code. You need to handle these exceptions. Third, you can
manually generate an exception by using the throw statement. No matter how an exception
is generated, it is handled in the same way.


#### Exception Handling Fundamentals

Java exception handling is managed via five keywords: try, catch, throw, throws, and
finally.

They form an interrelated subsystem in which the use of one implies the use of
another. 


Program statements that you want to monitor for exceptions are contained within a `try` block. 

If an exception occurs within the try block, it is thrown. Your code can catch this exception using `catch` and handle it in some rational manner.

System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword `throw`.

In some cases, an exception that is thrown out of a method must be specified as such by a `throws` clause. 

Any code that absolutely must be executed upon exiting from a try block is put in a `finally` block.


#### Using try and catch

At the core of exception handling are try and catch. These keywords work together; you can’t have a catch without a try.
```java
try {
	// block of code to monitor for errors
}
catch (ExcepType1 exOb) {
	// handler for ExcepType1
}
catch (ExcepType2 exOb) {
	// handler for ExcepType2
}
```


Here, ExcepType is the type of exception that has occurred. When an exception is thrown, it is
caught by its corresponding catch statement, which then processes the exception. As the general
form shows, there can be more than one catch statement associated with a try. The type of the
exception determines which catch statement is executed. That is, if the exception type specified
by a catch statement matches that of the exception, then that catch statement is executed (and all
others are bypassed). When an exception is caught, exOb will receive its value.

There is another form of the try statement that supports automatic resource
management. This form of try is called try-with-resources.

___

```java
class ExecDemo
{
	public static void main(String[] args)
	{
		int[] nums = new int[4];
		
		try
		{
			System.out.println("Before exeption is generated.");
			num[7] = 10; // out of bound
			System.out.println("This wont display");
		}
		catch(ArrayIndexOutOfBoundsExeption exec)
		{
			System.out.println("Index out-of-bounds!");
		}
		System.out.println("After catch statement.");
	}
}
```

```
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

catch is not called.
Rather, program execution is transferred to it. Thus, the println( ) statement following the out-of-
bounds index will never execute. After the catch statement executes, program control continues
with the statements following the catch. Thus, it is the job of your exception handler to remedy
the problem that caused the exception so that program execution can continue normally.

if no exception is thrown by a try block, no catch statements will be executed
and program control resumes after the catch statement.

#### Consequence of Uncaught Exception

In general, if your program does not catch an exception,
then it will be caught by the JVM. The trouble is that the JVM’s default exception handler
terminates execution and displays a stack trace and error message.

he type of the exception must match the type specified in a catch
statement. If it doesn’t, the exception won’t be caught.

#### Handling Errors Gracefully

One of the key benefits of exception handling is that it enables your program to respond
to an error and then continue running.

```java
// Handle error gracefully and continue.
class ExcDemo3 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128 };
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArithmeticException exc) 
			{
				// catch the exception
				System.out.println("Can't divide by Zero!");
			}
		}
	}
}
```


```
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
```

If a division by zero occurs, an ArithmeticException is generated. In the program, this exception is handled by reporting
the error and then continuing with execution. Thus, attempting to divide by zero does not cause
an abrupt run-time error resulting in the termination of the program. Instead, it is handled
gracefully, allowing program execution to continue.


___

#### Using Multiple catch Statements

you can associate more than one catch statement with a try. In fact, it is
common to do so. However, each catch must catch a different type of exception.

```java
// Handle error gracefully and continue.
class ExcDemo4 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };  // longer than denum
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArithmeticException exc) 
			{
				// catch the exception
				System.out.println("Can't divide by Zero!");
			}
			catch (ArrayIndexOutOfBoundsException exc)
			{
				System.out.println("No matching element found.");
			}
		}
	}
}
```

```
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
No matching element found.
```

As the output confirms, each catch statement responds only to its own type of exception.

___

#### Catching Subclass Exceptions

since the superclass
of all exceptions is Throwable, to catch all possible exceptions, catch Throwable. If you want
to catch exceptions of both a superclass type and a subclass type, put the subclass first in the
catch sequence. If you don’t, then the superclass catch will also catch all derived classes. This
rule is self-enforcing because putting the superclass first causes unreachable code to be created, since the subclass catch clause can never execute. 

In Java, unreachable code is an error.

```java
// Handle error gracefully and continue.
class ExcDemo4 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };  // longer than denum
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArrayIndexOutOfBoundsException exc)
			{ // catch subclass
				System.out.println("No matching element found.");
			}
			catch (Throwable exc) 
			{ // catch superclass
				System.out.println("Some Exception occured!");
			}
		}
	}
}
```

```
4 / 2 is 2
Some exception occurred.
16 / 4 is 4
32 / 4 is 8
Some exception occurred.
128 / 8 is 16
No matching element found.
No matching element found.
```


____

First, if you add a catch clause
that catches exceptions of type Exception, then you have effectively added a “catch all”
clause to your exception handler that deals with all program-related exceptions. Such a
“catch all” clause might be useful in a situation in which abnormal program termination
must be avoided no matter what occurs. Second, in some situations, an entire category of
exceptions can be handled by the same clause. Catching the superclass of these exceptions
allows you to handle all without duplicated code.

___


#### Try blocks can be nested

Often nested try blocks are used to allow
different categories of errors to be handled in different ways. Some types of errors are
catastrophic and cannot be fixed. Some are minor and can be handled immediately. You might
use an outer try block to catch the most severe errors, allowing inner try blocks to handle less
serious ones.

___

#### Throwing an Exception

The preceding examples have been catching exceptions generated automatically by the JVM.
However, it is possible to manually throw an exception by using the throw statement. Its general
form is shown here:
`throw exceptOb;`

Here, exceptOb must be an object of an exception class derived from Throwable.

```java
// Manually throw an exception.

class ThrowDemo 
{
	public static void main(String[] args) 
	{
		try 
		{
			System.out.println("Before throw.");
			throw new ArithmeticException();
		}
		catch (ArithmeticException exc) 
		{
			// catch the exception
			System.out.println("Exception caught.");
		}
		System.out.println("After try/catch block.");
	}
}
```

```
Before throw.
Exception caught.
After try/catch block.
```

ArithmeticException was created using new in the throw statement.
Remember, throw throws an object. Thus, you must create an object for it to throw. That is,
you can’t just throw a type.


___

#### Rethrowing an Exception

An exception caught by one catch statement can be rethrown so that it can be caught by an
outer catch. The most likely reason for rethrowing this way is to allow multiple handlers
access to the exception. For example, perhaps one exception handler manages one aspect of
an exception, and a second handler copes with another aspect. Remember, when you rethrow
an exception, it will not be recaught by the same catch statement. It will propagate to the next
catch statement.


```java
// Handle error gracefully and continue.
class Rethrow 
{
	public static void genException() 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };  // longer than denum
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch(ArithmeticException exc)
			{
				Syste.out.println("Can't divide by Zero!");
			}
			catch (ArrayIndexOutOfBoundsException exc)
			{ // catch subclass
				System.out.println("No matching element found.");
				
				throw exc;
				// rethrow exception
			}
		}
	}
}


class RethrowDemo
{
	public static void main(String[] args)
	{
		try
		{
			Rethrow.genException();
			// calling class
		}
		catch(ArrayIndexOutOfBoundsException exc)
		{
			System.out.println("Fatal error - " + "program terminated.");
		}
	}
}
```


divide-by-zero errors are handled locally, by genException( ), but an
array boundary error is rethrown. In this case, it is caught by main( ).

___


#### looking at Throwable

a catch clause specifies
an exception type and a parameter. The parameter receives the exception object. Since all
exceptions are subclasses of Throwable, all exceptions support the methods defined by
Throwable.

Of the methods defined by Throwable, two of the most interesting are printStackTrace( )
and toString( ). You can display the standard error message plus a record of the method calls
that lead up to the exception by calling printStackTrace( ). You can use toString( ) to retrieve
the standard error message. The toString( ) method is also called when an exception is used as
an argument to println( ).

```java
// Using the Throwable methods.
class ExcTest 
{
	static void genException() 
	{
		int[] nums = new int[4];
		System.out.println("Before exception is generated.");
		// generate an index out-of-bounds exception
		nums[7] = 10;
		System.out.println("this won't be displayed");
	}
}

class UseThrowableMethods 
{
	public static void main(String[] args) 
	{
		try 
		{
			ExcTest.genException();
		}
		catch (ArrayIndexOutOfBoundsException exc) 
		{
			// catch the exception
			System.out.println("Standard message is: ");
			System.out.println(exc);
			System.out.println("\nStack trace: ");
			exc.printStackTrace();
		}
		System.out.println("After catch Statement.");
	}
}
```

```
Before exception is generated.

Standard message is:
java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4

Stack trace:
java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 4
	at ExcTest.genException(UseThrowableMethods.java:10)
	at UseThrowableMethods.main(UseThrowableMethods.java:19)

After catch statement.
```


____

#### Using finally

an exception might cause an error that terminates the current method,
causing its premature return. However, that method may have opened a file or a network
connection that needs to be closed. Such types of circumstances are common in programming,
and Java provides a convenient way to handle them: finally.
To specify a block of code to execute when a try/catch block is exited, include a finally
block at the end of a try/catch sequence.

whether the try block ends normally, or because
of an exception, the last code executed is that defined by finally. The finally block is
also executed if any code within the try block or any of its catch statements return from
the method.

```java
// Use finally.
class UseFinally 
{
	public static void genException(int what) 
	{
		int t;
		int[] nums = new int[2];
		System.out.println("Receiving " + what);
		try 
		{
			switch(what) 
			{
				case 0:
					t = 10 / what; // generate div-by-zero error
					break;
				case 1:
					nums[4] = 4; // generate array index error.
					break;
				case 2:
					return; // return from try block
			}
		}
		catch (ArithmeticException exc) 
		{
			// catch the exception
			System.out.println("Can't divide by Zero!");
			return; // return from catch
		}
		catch (ArrayIndexOutOfBoundsException exc) 
		{
			// catch the exception
			System.out.println("No matching element found.");
		}
		finally 
		{
			System.out.println("Leaving try.");
			// Executed on way out of try/catch blocks
		}
	}
}


class FinallyDemo 
{
	public static void main(String[] args) 
	{
		for(int i=0; i < 3; i++) 
		{
			UseFinally.genException(i);
			System.out.println();
		}
	}
}
```

```
Receiving 0
Can't divide by Zero!
Leaving try.

Receiving 1
No matching element found.
Leaving try.

Receiving 2
Leaving try.
```

As the output shows, no matter how the try block is exited, the finally block is executed.


____


#### Using throws

In some cases, if a method generates an exception that it does not handle, it must declare that
exception in a throws clause.

```
ret-type methName(param-list) throws except-list {
	// body
}
```


Here, except-list is a comma-separated list of exceptions that the method might throw outside
of itself.

exceptions
that are subclasses of Error or RuntimeException don’t need to be specified in a throws list.
Java simply assumes that a method may throw one. All other types of exceptions do need to be
declared. Failure to do so causes a compile-time error.

___

when performing keyboard input, you needed to add the clause
throws java.io.IOException
to main( ). Now you can understand why. An input statement might generate an IOException,
and at that time, we weren’t able to handle that exception. Thus, such an exception would be
thrown out of main( ) and needed to be specified as such. Now that you know about exceptions,
you can easily handle IOException.

```java
// Use throws.
class ThrowsDemo 
{
	public static char prompt(String str)
		throws java.io.IOException 
		{
			System.out.print(str + ": ");
			return (char) System.in.read();
		}
		
	public static void main(String[] args) 
	{
		char ch;

		// Since prompt( ) might throw an exception, it is enclosed in a try block.
		try 
		{
			ch = prompt("Enter a letter");
		}
		catch(java.io.IOException exc) 
		{
			System.out.println("I/O exception occurred.");
			ch = 'X';
		}
		
		System.out.println("You pressed " + ch);
	}
}
```

prompt( ) method does not handle
IOException itself. Instead, it uses a throws clause, which means that the calling method must
handle it. In this example, the calling method is main( ), and it deals with the error.


IOException is fully qualified by its package name java.io.

Java’s I/O system is contained in the java.io package. Thus, the IOException is also contained there. It would also have been possible to import java.io and then refer to IOException directly.


____

#### Additional Exception Features

In addition to the exception handling features already discussed, modern versions of Java include
three more. 

The first supports automatic resource management, which automates the process of releasing a resource, such as a file, when it is no longer needed. It is based on an expanded form of try, called the `try-with-resources` statement.

The second feature is called multi-catch, 

Third is sometimes called final rethrow or more precise rethrow. 


Multi-catch allows two or more exceptions to be caught by the same catch clause. 

Instead of having to catch each
exception type individually, you can use a single catch clause to handle the exceptions without
code duplication.
To create a multi-catch, specify a list of exceptions within a single catch clause. You do this
by separating each exception type in the list with the OR operator. Each multi-catch parameter
is implicitly final. (You can explicitly specify final, if desired, but it is not necessary.) Because
each multi-catch parameter is implicitly final, it can't be assigned a new value.

```
catch(ArithmeticException | ArrayIndexOutOfBoundsException e) {
```

___

#### Built-in Exceptions

Inside the standard package java.lang, Java defines several exception classes. A few have been
used by the preceding examples. The most general of these exceptions are subclasses of the
standard type RuntimeException. 

Since java.lang is implicitly imported into all Java programs, many exceptions derived from RuntimeException are automatically available. 
they need not be included in any method’s throws list. In the language of Java, these are called
unchecked exceptions because the compiler does not check to see if a method handles or throws
these exceptions. The unchecked exceptions defined in java.lang are listed in Table 9-2. Table 9-3
lists those exceptions defined by java.lang that must be included in a method’s throws list if
that method can generate one of these exceptions and does not handle it itself. These are called
checked exceptions. In addition to the exceptions in java.lang, Java defines several other types of
exceptions that relate to other packages, such as IOException mentioned earlier.


Unchecked Exceptions

ExceptionMeaning
ArithmeticExceptionArithmetic error, such as integer divide-by-zero.
ArrayIndexOutOfBoundsExceptionArray index is out-of-bounds.
ArrayStoreExceptionAssignment to an array element of an incompatible type.
ClassCastExceptionInvalid cast.
EnumConstantNotPresentExceptionAn attempt is made to use an undefined enumeration value.
IllegalArgumentExceptionIllegal argument used to invoke a method.
IllegalCallerExceptionA method cannot be legally executed by the calling code.
IllegalMonitorStateExceptionIllegal monitor operation, such as waiting on an unlocked thread.
IllegalStateExceptionEnvironment or application is in incorrect state.
IllegalThreadStateExceptionRequested operation not compatible with current thread state.
IndexOutOfBoundsExceptionSome type of index is out-of-bounds.
LayerInstantiationExceptionA module layer cannot be created.
NegativeArraySizeExceptionArray created with a negative size.
NullPointerExceptionInvalid use of a null reference.
NumberFormatExceptionInvalid conversion of a string to a numeric format.
SecurityExceptionAttempt to violate security.
StringIndexOutOfBoundsExceptionAttempt to index outside the bounds of a string.
TypeNotPresentExceptionType not found.
UnsupportedOperationExceptionAn unsupported operation was encountered.

___

Checked Exceptions

ClassNotFoundExceptionClass not found.
CloneNotSupportedExceptionAttempt to clone an object that does not implement the
Cloneable interface.
IllegalAccessExceptionAccess to a class is denied.
InstantiationExceptionAttempt to create an object of an abstract class or interface.
InterruptedExceptionOne thread has been interrupted by another thread.
NoSuchFieldExceptionA requested field does not exist.
NoSuchMethodExceptionA requested method does not exist.
ReflectiveOperationExceptionSuperclass of reflection-related exceptions.

___

#### Creating Exception Subclass

you can manage errors that relate specifically to your application. Creating an
exception class is easy. Just define a subclass of Exception (which is, of course, a subclass of
Throwable). Your subclasses don’t need to actually implement anything—it is their existence in
the type system that allows you to use them as exceptions.

```java
/ Use a custom exception.
// Create an exception.
class NonIntResultException extends Exception {
int n;
int d;
NonIntResultException(int i, int j) {
n = i;
d = j;
}

public String toString() {
return "Result of " + n + " / " + d +
" is non-integer.";
}
}
class CustomExceptDemo {
public static void main(String[] args) {
// Here, numer contains some odd values.
int[] numer = { 4, 8, 15, 32, 64, 127, 256, 512 };
int[] denom = { 2, 0, 4, 4, 0, 8 };
for(int i=0; i<numer.length; i++) {
try {
if((numer[i]%2) != 0)
throw new
NonIntResultException(numer[i], denom[i]);
System.out.println(numer[i] + " / " +
denom[i] + " is " +
numer[i]/denom[i]);
}
catch (ArithmeticException exc) {
// catch the exception
System.out.println("Can't divide by Zero!");
}
catch (ArrayIndexOutOfBoundsException exc) {
// catch the exception
System.out.println("No matching element found.");
}
catch (NonIntResultException exc) {
System.out.println(exc);
}
}
}
}
```

```
4 / 2 is 2
Can't divide by Zero!
Result of 15 / 4 is non-integer.
32 / 4 is 8
Can't divide by Zero!
Result of 127 / 8 is non-integer.
No matching element found.
No matching element found.
```


In general, errors can be reported in two ways: return values
and exceptions. When is one approach better than the other? Simply put, in Java, exception
handling should be the norm. Certainly, returning an error code is a valid alternative in some
cases, but exceptions provide a more powerful, structured way to handle errors. They are the
way professional Java programmers handle errors in their code.

___

