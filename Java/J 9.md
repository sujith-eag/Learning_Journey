
## Chapter 7 : Inheritance

●Understand inheritance basics
●Call superclass constructors
●Use super to access superclass members
●Create a multilevel class hierarchy
●Know when constructors are called
●Understand superclass references to subclass objects
●Override methods
●Use overridden methods to achieve dynamic method dispatch
●Use abstract classes
●Use final
●Know the Object class


___

Using inheritance, you can create a general
class that defines traits common to a set of related items. This class can then be inherited by
other, more specific classes, each adding those things that are unique to it. it
allows the creation of hierarchical classifications.

In the language of Java, a class that is inherited is called a superclass. The class that
does the inheriting is called a subclass. Therefore, a subclass is a specialized version of a
superclass. It inherits all of the variables and methods defined by the superclass and adds its
own, unique elements.


Java supports inheritance by allowing one class to incorporate another class into its declaration.
This is done by using the extends keyword

___

The following program creates a superclass called TwoDShape, which stores the width and
height of a two-dimensional object, and a subclass called Triangle.

```java
class TwoDShape
{
	double width;
	double height;
	
	void showDim()
	{
		System.out.println("width and height are " + width + " and " + height);
	}
}

class Triangle extends TwoDShape // inherits TwoDShape
{
	String style;
	
	double area()
	{
		return width* height/2;
	}  // can refer to TwoDShape members directly
	
	void shoStyle()
	{
		System.out.println("Triangle is " + style);
	}
}

class Shape
{
	public static void main(String[] args)
	{
		Triangle t1 = new Triangle();
		Triangle t2 = new Triangle();
		
	 // members of TwoDShape are available to triangle
		t1.width = 4.0;
		t1.height = 4.0;
		t1.style = "filled";
		
		t2.width = 8.0;
		t2.height = 12.0;
		t2.style = "outlined";
		
		System.out.println("Info for t1: ");
		t1.showStyle();
		t1.showDim();
		System.out.println("Area is " + t1.area());

		System.out.println();
		
		System.out.println("Info for t2: ");
		t2.showStyle();
		t2.showDim();
		System.out.println("Area is " + t2.area());
	}
}
```

```
Info for t1:
Triangle is filled
Width and height are 4.0 and 4.0
Area is 8.0

Info for t2:
Triangle is outlined
Width and height are 8.0 and 12.0
Area is 48.0
```


Here, TwoDShape defines the attributes of a “generic” two-dimensional shape, such as a
square, rectangle, triangle, and so on. The Triangle class creates a specific type of TwoDShape,
in this case, a triangle. The Triangle class includes all of TwoDShape and adds the field style,
the method area( ), and the method showStyle( ). The triangle’s style is stored in style.

Because Triangle includes all of the members of its superclass, TwoDShape, it can access
width and height inside area( ). Also, inside main( ), objects t1 and t2 can refer to width and
height directly, as if they were declared by Triangle.

Even though TwoDShape is a superclass for Triangle, it is also a completely independent,
stand-alone class. Being a superclass for a subclass does not mean that the superclass cannot
be used by itself.

General form of class declaration that inherits a superclass is is
```java
class subclass-name extends superclass-name {
	// body of class
}
```

You can specify only one superclass for any subclass that you create. Java does not support
the inheritance of multiple superclasses into a single subclass. (This differs from C++, in
which you can inherit multiple base classes)

You can, however, create a hierarchy of inheritance in which a subclass becomes
a superclass of another subclass.

```java
// A subclass of TwoDShape for rectangles.

class Rectangle extends TwoDShape 
{
	boolean isSquare() 
	{
		if(width == height) return true;
			return false;
	}
	double area() 
	{
		return width * height;
	}
}
```

___

#### Member Access and Inheritance

Inheriting a class does not overrule the private
access restriction. Thus, even though a subclass includes all of the members of its superclass,
it cannot access those members of the superclass that have been declared private.

if width and height are made private in TwoDShape, then Triangle will not be able to access them:

a class member that has been declared private will remain private to its
class. It is not accessible by any code outside its class, including subclasses. accessor methods to provide access to the private members of a class.

```java
class TwoDShape
{
	private double width;
	private double height;

	// Accessor methods for private members
	double getWidth() { return width;}
	double getHeight() { return height;}
	void setWidth(double w) { width = w;}
	void setHeight(double h) { height = h;}

	void showDim()
	{
		System.out.println("width and height are " + width + " and " + height);
	}
}

class Triangle extends TwoDShape // inherits TwoDShape
{
	String style;
	
	double area()
	{
		return getWidth() * getHeight()/2;
	}  // using accessor methods of TwoDShape
	
	void showStyle()
	{
		System.out.println("Triangle is " + style);
	}
}

class Shapes
{
	public static void main(String[] args)
	{
		Triangle t1 = new Triangle();
		Triangle t2 = new Triangle();
		
	 // members of TwoDShape are available to triangle
		t1.setWidth(4.0);
		t1.setHeight(4.0);
		t1.style = "filled";
		
		t2.setWidth(8.0);
		t2.setHeight(12.0);
		t2.style = "outlined";
		
		System.out.println("Info for t1: ");
		t1.showStyle();
		t1.showDim();
		System.out.println("Area is " + t1.area());

		System.out.println();
		
		System.out.println("Info for t2: ");
		t2.showStyle();
		t2.showDim();
		System.out.println("Area is " + t2.area());
	}
}
```

There are no hard and fast rules, but here are two general principles. If an instance variable
is to be used only by methods defined within its class, then it should be made private. 

If an instance variable must be within certain bounds, then it should be private and made available only through accessor methods. This way, you can prevent invalid values from being assigned.

___

#### Constructors and Inheritance

The constructor for the superclass constructs the superclass portion of the object, and the constructor for the subclass constructs the subclass part.

in practice, most classes will have explicit constructors.

When only the subclass defines a constructor, the process is straightforward: simply
construct the subclass object. The superclass portion of the object is constructed automatically using its default constructor.

```java
// Constructor for Triangle

class Triangle extends TwoDShape 
{
	private String style;
	
	// Constructor
	Triangle(String s, double w, double h) 
	{
		setWidth(w);
		setHeight(h);
		// Initialize TwoDShape portion of object.
		style = s;
	}
```

Here, Triangle’s constructor initializes the members of TwoDClass that it inherits along with its own style field.

___

#### Using super to call Superclass Constructor

When both the superclass and the subclass define constructors, the process is a bit more
complicated because both the superclass and subclass constructors must be executed. In this
case, you must use another of Java’s keywords, super, which has two general forms. The
first calls a superclass constructor. The second is used to access a member of the superclass
that has been hidden by a member of a subclass.


`super(parameter-list);` 
super( ) must always be the first statement executed inside a subclass constructor.

```java
class TwoDShape
{
	private double width;
	private double height;

	// Parameterized constructor
	TwoDShape(double w, double h)
	{
		width = w;
		height = h;
	}
	
	// Accessor methods for private members
	double getWidth() { return width;}
	double getHeight() { return height;}
	void setWidth(double w) { width = w;}
	void setHeight(double h) { height = h;}

	void showDim()
	{
		System.out.println("width and height are " + width + " and " + height);
	}
}

class Triangle extends TwoDShape // inherits TwoDShape
{
	private String style;
	
	Triangle(String s, double w, double h)
	{
		super(w, h); // call superclass constructor
		
		style = s;
	}
	
	double area()
	{
		return getWidth() * getHeight()/2;
	}  // using accessor methods of TwoDShape
	
	void showStyle()
	{
		System.out.println("Triangle is " + style);
	}
}

class Shapes
{
	public static void main(String[] args)
	{
		Triangle t1 = new Triangle("filled", 4.0, 4.0);
		Triangle t2 = new Triangle("outlined", 8.0, 12.0);
		
		System.out.println("Info for t1: ");
		t1.showStyle();
		t1.showDim();
		System.out.println("Area is " + t1.area());

		System.out.println();
		
		System.out.println("Info for t2: ");
		t2.showStyle();
		t2.showDim();
		System.out.println("Area is " + t2.area());
	}
}
```

Here, Triangle( ) calls super( ) with the parameters w and h. This causes the TwoDShape( )
constructor to be called, which initializes width and height using these values. Triangle
no longer initializes these values itself. It need only initialize the value unique to it: style.

Any form of constructor defined by the superclass can be called by super( ). 

This can be expanded by adding default constructors and constructors that take one argument (constructor overloading)

```java
class TwoDShape
{
	private double width;
	private double height;
	
	// A default Constructor
	TwoDShape()
	{
		width = height = 0.0;
	}
	
	// Parameterized constructor
	TwoDShape(double w, double h)
	{
		width = w;
		height = h;
	}
	
	// Construct object with equal height and width
	TwoDShape(double x)
	{
		width = height = x;
	}
	
	// Accessor methods for private members
	double getWidth() { return width;}
	double getHeight() { return height;}
	void setWidth(double w) { width = w;}
	void setHeight(double h) { height = h;}

	void showDim()
	{
		System.out.println("width and height are " + width + " and " + height);
	}
}

class Triangle extends TwoDShape // inherits TwoDShape
{
	private String style;
	
	// Default Constructor
	Triangle()
	{
		super(); // calling default for superclass 
		style = "none";
	}
	
	// Constructor 
	Triangle(String s, double w, double h)
	{
		super(w, h); // call superclass constructor
		
		style = s;
	}
	
	// One argument constructor
	Triangle(double x)
	{
		super(x);
		
		style = "filled";
	}
	
	double area()
	{
		return getWidth() * getHeight()/2;
	}  // using accessor methods of TwoDShape
	
	void showStyle()
	{
		System.out.println("Triangle is " + style);
	}
}

class Shapes
{
	public static void main(String[] args)
	{
		Triangle t1 = new Triangle();
		Triangle t2 = new Triangle("outlined", 8.0, 12.0);
		Triangle t3 = new Triangle(4.0);
		
		t1 = t2;
		
		System.out.println("Info for t1: ");
		t1.showStyle();
		t1.showDim();
		System.out.println("Area is " + t1.area());

		System.out.println();
		
		System.out.println("Info for t2: ");
		t2.showStyle();
		t2.showDim();
		System.out.println("Area is " + t2.area());
		
		System.out.println();
		
		System.out.println("Info for t3: ");
		t3.showStyle();
		t3.showDim();
		System.out.println("Area is " + t3.area());
	}
}
```

```
$ java Shapes 

Info for t1: 
Triangle is outlined
width and height are 8.0 and 12.0
Area is 48.0

Info for t2: 
Triangle is outlined
width and height are 8.0 and 12.0
Area is 48.0

Info for t3: 
Triangle is filled
width and height are 4.0 and 4.0
Area is 8.0
```

____

#### Using super to Access Superclass Members


There is a second form of super that acts somewhat like this, except that it always refers to the
superclass of the subclass in which it is used. This usage has the following general form:
`super.member`

Here, member can be either a method or an instance variable.
This form of super is most applicable to situations in which member names of a subclass
hide members by the same name in the superclass.

```java
// Using super to overcome name hiding.

class A 
{
	int i;
}

// Create a subclass by extending class A.
class B extends A 
{
	int i; // this i hides the i in A
	// Constructor
	B(int a, int b) 
	{
		super.i = a; // refers to i in A
		i = b; // i in B
	}
	
	void show() 
	{
		System.out.println("i in superclass: " + super.i);
		System.out.println("i in subclass: " + i);
	}
}

class UseSuper 
{
	public static void main(String[] args) 
	{
		B subObject = new B(1, 2);
		subObject.show();
	}
}
```

```
i in superclass: 1
i in subclass: 2
```

Although the instance variable i in B hides the i in A, super allows access to the i defined in the superclass. super can also be used to call methods that are hidden by a subclass.

____

#### Creating multilevel hierarchy

subclass Triangle is used as a superclass to create the subclass called ColorTriangle.
ColorTriangle inherits all of the traits of Triangle and TwoDShape and adds a field called
color, which holds the color of the triangle.


```java
// A multilevel hierarchy

class TwoDShape
{
	private double width;
	private double height;
	
	// A default Constructor
	TwoDShape()
	{
		width = height = 0.0;
	}
	
	// Parameterized constructor
	TwoDShape(double w, double h)
	{
		width = w;
		height = h;
	}
	
	// Construct object with equal height and width
	TwoDShape(double x)
	{
		width = height = x;
	}
	
	// Accessor methods for private members
	double getWidth() { return width;}
	double getHeight() { return height;}
	void setWidth(double w) { width = w;}
	void setHeight(double h) { height = h;}

	void showDim()
	{
		System.out.println("width and height are " + width + " and " + height);
	}
}

// Extend TwoDShape
class Triangle extends TwoDShape
{
	private String style;
	
	// Default Constructor
	Triangle()
	{
		super(); // calling default for superclass 
		style = "none";
	}
	
	// Constructor
	Triangle(String s, double w, double h)
	{
		super(w, h); // call superclass constructor
		
		style = s;
	}
	
	// One argument constructor
	Triangle(double x)
	{
		super(x);
		
		style = "filled";
	}
	
	double area()
	{
		return getWidth() * getHeight()/2;
	}  // using accessor methods of TwoDShape
	
	void showStyle()
	{
		System.out.println("Triangle is " + style);
	}
}

// Extend Triangle ( decendent of TwoDShape)
class ColorTriangle extends Triangle
{
	private String color; 
	
	ColorTriangle(String c, String s, double w, double h)
	{
		super(s, w, h);
		color = c;
	}
	
	String getColor() { return color; }
	
	void showColor()
	{
		System.out.println("Color is " + color);
	}
}


class Shapes
{
	public static void main(String[] args)
	{
		ColorTriangle t1 = new ColorTriangle("Blue","outlined", 8.0, 12.0 );

		ColorTriangle t2 = new Triangle("Red", "filled", 2.0, 2.0);
		
		System.out.println("Info for t1: ");
		t1.showStyle();
		t1.showDim();
		t1.showColor();
		System.out.println("Area is " + t1.area());
		
		System.out.println();
		
		System.out.println("Info for t2: ");
		t2.showStyle();
		t2.showDim();
		t2.showcolor();
		System.out.println("Area is " + t2.area());
	}
}
```

```
Info for t1:
Triangle is outlined
Width and height are 8.0 and 12.0
Color is Blue
Area is 48.0

Info for t2:
Triangle is filled
Width and height are 2.0 and 2.0
Color is Red
Area is 2.0
```

____

super( ) always refers to the constructor
in the closest superclass. The super( ) in ColorTriangle calls the constructor in Triangle. The
super( ) in Triangle calls the constructor in TwoDShape. In a class hierarchy, if a superclass
constructor requires parameters, then all subclasses must pass those parameters “up the line.”
This is true whether or not a subclass needs parameters of its own.

___

since super( ) must be the first statement executed in a subclass’
constructor, this order is the same whether or not super( ) is used. If super( ) is not used, then
the default (parameterless) constructor of each superclass will be executed.

constructors complete their execution in order of derivation, from superclass to subclass.


___

#### Method Overriding

In a class hierarchy, when a method in a subclass has the same return type and signature as a
method in its superclass, then the method in the subclass is said to override the method in the
superclass. When an overridden method is called from within a subclass, it will always refer
to the version of that method defined by the subclass. The version of the method defined by
the superclass will be hidden.

```java
// Method overriding.

class A 
{
	int i, j;
	A(int a, int b) 
	{
		i = a;
		j = b;
	}
	// display i and j
	void show() 
	{
		System.out.println("i and j: " + i + " " + j);
	}
}

class B extends A 
{
	int k;
	
	B(int a, int b, int c) 
	{
		super(a, b);
		k = c;
	}
	// display k – this overrides show() in A
	void show() 
	{
		System.out.println("k: " + k);
	}
}

class Override
{
	public static void main(String[] args) 
	{
		B subOb = new B(1, 2, 3);
		subOb.show(); // this calls show() in B
	}
}
```

```
k: 3
```

If you want to access the superclass version of an overridden method, you can do so by using super.

```java
class B extends A 
{
	int k;
	
	B(int a, int b, int c) 
	{
		super(a, b);
		k = c;
	}
	
	void show() 
	{
		super.show(); // calls A's Show
		System.out.println("k: " + k);
	}
}
```

```
i and j: 1 2
k: 3
```

Method overriding occurs only when the signatures of the two methods are identical. If they are not, then the two methods are simply overloaded.

___

#### Overridden methods support Polymorphism

Method overriding forms the basis for one of Java’s most powerful concepts: dynamic method dispatch. Dynamic method dispatch is the mechanism by which a call to an overridden method is resolved at run time rather than compile time. Dynamic method dispatch is important because this is how Java implements run-time polymorphism.

When an overridden method is called through a superclass reference, Java determines which
version of that method to execute based upon the type of the object being referred to at the time
the call occurs. Thus, this determination is made at run time. When different types of objects are
referred to, different versions of an overridden method will be called. In other words, it is the
type of the object being referred to (not the type of the reference variable) that determines which
version of an overridden method will be executed. Therefore, if a superclass contains a method
that is overridden by a subclass, then when different types of objects are referred to through a
superclass reference variable, different versions of the method are executed.

```java
// Demonstrate dynamic method dispatch.
class Sup 
{
	void who() 
	{
		System.out.println("who() in Sup");
	}
}

class Sub1 extends Sup 
{
	void who() 
	{
		System.out.println("who() in Sub1");
	}
}
class Sub2 extends Sup 
{
	void who() 
	{
		System.out.println("who() in Sub2");
	}
}

class DynDispDemo 
{
	public static void main(String[] args) 
	{
		Sup superOb = new Sup();
		Sub1 subOb1 = new Sub1();
		Sub2 subOb2 = new Sub2();
		
		Sup supRef;
		
		supRef = superOb;
		supRef.who();
		
		supRef = subOb1;
		supRef.who();
		
		supRef = subOb2;
		supRef.who();
	}
}
```

```
who() in Sup
who() in Sub1
who() in Sub2
```

In each case, the version of who( ) to call is determined at run time by the type of object being referred to.


As the output shows, the version of who( ) executed is determined by the type of object being referred to at the time of the call, not by the class type of supRef.

___


Readers familiar with C++ will recognize that overridden methods in Java are
equivalent in purpose and similar in operation to virtual functions in C++.

___

#### Using Abstract Classes



____

#### Using final

Whatever the reason, in Java it is easy to prevent a method
from being overridden or a class from being inherited by using the keyword final.

To prevent a method from being overridden, specify final as a modifier at the start of its declaration. Methods declared as final cannot be overridden.
Because meth( ) is declared as final, it cannot be overridden in B. If you attempt to do so, a compile-time error will result.
```java
class A 
{
	final void meth() 
	{
		System.out.println("This is a final method.");
	}
}

class B extends A 
{
	void meth() 
	{ // ERROR! Can't override.
		System.out.println("Illegal!");
	}
}
```

You can prevent a class from being inherited by preceding its declaration with final. Declaring a
class as final implicitly declares all of its methods as final, too. 

```java
final class A {
	// ...
}

// The following class is illegal.
class B extends A { // ERROR! Can't subclass A
	// ...
}
```

As you might expect, it is illegal to declare a class as both abstract and final since an abstract class is incomplete by itself and relies upon its subclasses to provide complete implementations.

Beginning with JDK 17, the ability to seal a class was added to Java. Sealing offers fine-grained control over inheritance.

____

Using final with Data members

final can also be applied to member variables to create
what amounts to named constants. If you precede an instance variable’s name with final, its value
cannot be changed throughout the lifetime of your program.

Making a final member variable static lets you refer to the
constant through its class name rather than through an object.

Declaring a parameter final prevents it from being changed within the method. 

Declaring a local variable final prevents it from being assigned a value more than once.


#### Object Class

Java defines one special class called Object that is an implicit superclass of all other classes.
In other words, all other classes are subclasses of Object. This means that a reference variable
of type Object can refer to an object of any other class.

Object defines the following methods, which means that they are available in every object:

```
Object clone( )  - Creates a new object that is the same as the object being cloned.


boolean equals(Object object) - Determines whether one object is equal to another.


void finalize( )  - Called before an unused object is recycled. (Deprecated by JDK 9.)


int hashCode( ) - Returns the hash code associated with the invoking object.


Class<?> getClass( ) - Obtains the class of an object at run time.


void notify( ) - Resumes execution of a thread waiting on the invoking object.


void notifyAll( ) - Resumes execution of all threads waiting on the invoking object.


String toString( ) - Returns a string that describes the object.


void wait( ) 
void wait(long milliseconds)
void wait(long milliseconds, int nanoseconds)

Waits on another thread of execution.
```

The methods getClass( ), notify( ), notifyAll( ), and wait( ) are declared as final. You can override the others.

equals( ) and toString( ). The equals( ) method compares two objects. It returns true if the objects are equal, and false otherwise.

The toString( ) method returns a string that contains a description of the object on which it is called. Also, this method is automatically called when an object is output using println( ).

____

