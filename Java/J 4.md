
## Chapter 2 : Data Types and Operators

Key Skills & Concepts
●Know Java’s primitive types
●Use literals
●Initialize variables
●Know the scope rules of variables within a method
●Use the arithmetic operators
●Use the relational and logical operators
●Understand the assignment operators
●Use shorthand assignments
●Understand type conversion in assignments
●Cast incompatible types
●Understand type conversion in expressions


___


Data types are especially important in Java because it is a strongly typed language. All operations are type-checked by the compiler for type compatibility. Illegal operations will not be compiled. 

Thus, strong type checking helps prevent errors and enhances reliability. To enable strong type checking, all variables, expressions, and values have a type. There is no concept of a “type-less” variable.

The type of a value determines what operations are allowed on it. An operation allowed on one type might not be allowed on another.


___

#### Primitive Data Types

Java contains two general categories of built-in data types: object-oriented and non-object-
oriented. Java’s object-oriented types are defined by classes

at the core of Java are eight primitive (also called elemental or simple) types of data, which means they are not objects but binary values.

boolean - Represents true/false values

char  - Character. char is an unsigned 16-bit type having a range of 0 to 65,535. A character variable can be assigned a value by enclosing the character in single quotes. `char Ch; ch = 'X';`


byte   - 8-bit integer
int  - Integer
long  - Long integer
short  - Short integer
```
Type   Width    range
byte    8        –128 to 127

short  16       –32,768 to 32,767

int     32      –2,147,483,648 to 2,147,483,647

long    64      –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
```


float  - Single-precision floating point - 32 bit wide 
double  - Double-precision floating point - 64 bit wide


All of Java’s other data types are constructed from these primitive types.

____

#### Literals

In Java, literals refer to fixed values that are represented in their human-readable form. For
example, the number 100 is a literal. Literals are also commonly called constants.

10 and –100 are integer literals.
 11.123 is a floating-point literal.


You can embed one or more underscores into an integer or floating-point literal. Doing so
can make it easier to read values consisting of many digits. When the literal is compiled, the
underscores are simply discarded. Here is an example:
123_45_1234
This specifies the value 123,451,234. The use of underscores is particularly useful when
encoding things like part numbers, customer IDs, and status codes that are commonly thought
of as consisting of subgroups of digits.

#### Character escape sequences

Enclosing character constants in single quotes works for most printing characters, but a few
characters, such as the carriage return, pose a special problem when a text editor is used

These
sequences are used in place of the characters that they represent.

Escape SequenceDescription
\'Single quote
\"Double quote
\\Backslash
\rCarriage return
\nNew line
\fForm feed
\tHorizontal tab
\bBackspace
\dddOctal constant (where ddd is an octal constant)
\uxxxxHexadecimal constant (where xxxx is a hexadecimal constant)
\sSpace (added by JDK 15)
\endoflineContinue line (applies to only text block; added by JDK 15)


___

#### String Literals

the string. A string is a set of characters enclosed by
double quotes. For example,
"this is a test"
is a string.

In addition to normal characters, a string literal can also contain one or more of the escape
sequences just described.

```java
class StrDemo
{
	public static void main(String[] args)
	{
		System.out.println("First line\nSecond line");
		System.out.println("A\t\B\tC");
	}
}
```

A character literal represents a single letter of type char  `'k'`. 

A string containing only one letter is still a string. Although strings consist of characters, they are not the same type `"k"`.

____

#### Operators

An operator is a symbol that tells the compiler
to perform a specific mathematical or logical manipulation. Java has four general classes
of operators: arithmetic, bitwise, relational, and logical.

Arithmetic : `+ - *  /  %  ++  --`
These can also be applied to any builtin numeric data type and also on Objects of type `char`.

Relational Operators : `==  !=  <  >  <= >=`

Logical Operators : `& - AND` , `| - OR`, `^ - XOR`, `|| - Short-circuit OR`  , `&& - Short-circuit AND`, `! - NOT`

The outcome of the relational and logical operators is a boolean value.

___

In Java, all objects can be compared for equality or inequality using = = and !=.

the comparison operators, <, >, <=, or >=, can be applied only to those types that support an
ordering relationship.

values of type boolean can only be compared for equality
or inequality, since the true and false values are not ordered `true > false` has no meaning in java.

___

Using Short Circuit operator to prevent division by Zero.
```java
class SCOps 
{
	public static void main(String[] args)
	{
		int n, d, q;
		n = 10;
		d = 2;
		
		if (d!= 0 && (n%d) == 0)
			System.out.println(d + " is a factor of " + n);

		d = 0;
		if (d!= 0 && (n%d) == 0)
			System.out.println(d + " is a factor of " + n);
	}
}
```

Difference of Logical and Short circuit operators
```java
class SideEffects 
{
	public static void main(String[] args) 
	{
		int i;
		i = 0;
	
		/* Here, i is still incremented even though the if statement fails. */
		if(false & (++i < 100))
		System.out.println("this won't be displayed");
		System.out.println("if statement executed: " + i); // displays 1
	
		
		/* In this case, i is not incremented because the short-circuit operator skips the increment. */
		if(false && (++i < 100))
		System.out.println("this won't be displayed");
		System.out.println("if statement executed: " + i); // still 1 !!
	}
}
```

in the first if statement, i is incremented whether the if
succeeds or not. However, when the short-circuit operator is used, the variable i is not
incremented when the first operand is false.


___

#### Assignment Operator

Chain of assignment  `x = y = z = 100;`

Shorthand Assignment `x = x+10;` is `x += 10;`


```
+=  –=  *=  /=  %=  &=  |=  ^=
```

___

#### Type Conversion in Assignments

When compatible types are mixed in an assignment, the value of the right side is automatically converted to the type of the left side.

```
int i;
float f;
i = 10;
f = i; // assign an int to a float
```

boolean and int are not compatible.
When one type of data is assigned to another type of variable, an automatic type
conversion will take place if
●The two types are compatible.
●The destination type is larger than the source type.

When these two conditions are met, a widening conversion takes place.

___

#### Casting Incompatible types

Although the automatic type conversions are helpful, they will not fulfill all programming needs
because they apply only to widening conversions between compatible types. For all other cases
you must employ a cast. A cast is an instruction to the compiler to convert one type into another.
Thus, it requests an explicit type conversion. A cast has this general form:
`(target-type) expression`

Here, target-type specifies the desired type to convert the specified expression to. For example,
if you want to convert the type of the expression x/y to int, you can write
```
double x, y;
// ...
(int) (x / y)
```

he cast is necessary here because there is
no automatic conversion from double to int.

The parentheses surrounding x / y are necessary. Otherwise, the cast to int would apply
only to the x and not to the outcome of the division.

When a cast involves a narrowing conversion, information might be lost.

```java
class CastDemo
{
	Public static void main(String[] args)
	{
		double x, y;
		byte b;
		int i;
		char ch;
		
		x = 10.0;
		y = 3.0;
		
		i = (int) (x/y); // Truncation will occur
		System.out.println("Integer outcome of x/y: " + i);
		
		i = 100;
		b = (byte) i;  // No info lost
		System.out.println("Value of b: " + b);
		
		i = 257;
		b = (byte) i; // Info lost
		System.out.println("Value of b: " + b);
		
		b = 88;  // ASCII for X
		char = (char) b;
		System.out.println("ch: " + ch);
	}
}
```

```
Integer outcome of x / y: 3
Value of b: 100
Value of b: 1
ch: X
```


___

#### Operator Precedence


___

## Expressions

### Type conversion in Expressions

Within an expression, it is possible to mix two or more different types of data as long as they
are compatible with each other. For example, you can mix short and long within an expression
because they are both numeric types. When different types of data are mixed within an
expression, they are all converted to the same type. This is accomplished through the use of
Java’s type promotion rules.
First, all char, byte, and short values are promoted to int. Then, if one operand is a
long, the whole expression is promoted to long. If one operand is a float operand, the entire
expression is promoted to float. If any of the operands is double, the result is double.


Type promotion only
affects the evaluation of an expression.
if the value of a byte variable is promoted to int
inside an expression, outside the expression, the variable is still a byte.

___

```java
// A Type Promotion Surprise

class PromDemo
{
	public static void main(String[] args)
	{
		byte b;
		int i;
		
		b = 10;
		i = b * b;  // No case needed
		
		b = 10;
		b = (byte) (b * b);
		Syste.out.println("i and b: "+ i + " " + b);
	}
}
```

Somewhat counterintuitively, no cast is needed when assigning b*b to i, because b is
promoted to int when the expression is evaluated. However, when you try to assign b * b to b,
you do need a cast—back to byte! Keep this in mind if you get unexpected type-incompatibility
error messages on expressions that would otherwise seem perfectly OK.
This same sort of situation also occurs when performing operations on chars. For example,
in the following fragment, the cast back to char is needed because of the promotion of ch1 and
ch2 to int within the expression:

```java
char ch1 = 'a', ch2 = 'b';

ch1 = (char) (ch1 + ch2);
```

Without the cast, the result of adding ch1 to ch2 would be int, which can’t be assigned to a char.

```java
class UseCast 
{
	public static void main(String[] args)
	{
		int i;
		for(i = 0; i < 5; i++)
		{
			System.out.println(i + " /3: " + i/3);
			System.out.println(i + " /3 with fractions: " + (double) i/3);
			System.out.println();
		}
	}
}
```

```
0 / 3: 0
0 / 3 with fractions: 0.0
1 / 3: 0
1 / 3 with fractions: 0.3333333333333333
2 / 3: 0
2 / 3 with fractions: 0.6666666666666666
3 / 3: 1
3 / 3 with fractions: 1.0
4 / 3: 1
4 / 3 with fractions: 1.3333333333333333
```

___

An expression in Java may have tabs and spaces in it to make it more readable.

```
x=10/y*(127/x);

x = 10 / y * (127/x);
```

Parentheses increase the precedence of the operations contained within them, just like in
algebra. Use of redundant or additional parentheses will not cause errors or slow down the
execution of the expression.

```
x = y/3-34*temp+127;

x = (y/3) - (34*temp) + 127;
```


___



