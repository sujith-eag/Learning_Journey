
## Chapter 5 : More Data Types and Operators

Key Skills & Concepts
●Understand and create arrays
●Create multidimensional arrays
●Create irregular arrays
●Know the alternative array declaration syntax
●Assign array references
●Use the length array member
●Use the for-each style for loop
●Work with strings
●Apply command-line arguments
●Use type inference with local variables
●Use the bitwise operators
●Apply the ? operator


____

#### Arrays


An array is a collection of variables of the same type, referred to by a common name.

arrays in Java can be used just like arrays in other programming languages,
they have one special attribute: they are implemented as objects.

To declare a one-dimensional array, you can use this general form:
`type[ ] array-name = new type[size];`

type declares the element type of the array. (The element type is also commonly referred
to as the base type.) The element type determines the data type of each element contained in the
array. The number of elements that the array will hold is determined by size. Since arrays are
implemented as objects, the creation of an array is a two-step process. First, you declare an array
reference variable. Second, you allocate memory for the array, assigning a reference to that memory
to the array variable. Thus, arrays in Java are dynamically allocated using the new operator.

```java
int[] sample = new int[10];

int[] sample;
sample = new int[10];
```

An individual element within an array is accessed by use of an index. An index describes
the position of an element within an array. In Java, all arrays have zero as the index of their
first element.

```java
class ArrayDemo
{
	public static void main(String[] args)
	{
		int[] sample = new int[10];
		
		int i;
		for(i=0; i<10; i++)
			sample[i] = i;
		
		for(i=0; i<10; i++)
			System.out.println("This is [" + i + "] :" + sample[i] );
	}
}
```

To find Min and max in an array
```java
class MinMax 
{
	public static void main(String[] args)
	{
		int[] nums = new int[10];
		int min, max;
		
		nums[0] = 99;
		nums[1] = -10;
		nums[2] = 100123;
		nums[3] = 18;
		nums[4] = -978;
		nums[5] = 5623;
		nums[6] = 463;
		nums[7] = -9;
		nums[8] = 287;
		nums[9] = 49;
		
		min = max = nums[0]  // assuming
		
		for(int i=1; i<10; i++)
		{
			if( nums[i] < min )
				min = nums[i];
			if( nums[i] > max)
				max = nums[i];
		}
		System.out.println("min and max: " + min + " " + max);
	}
}
```

```
min and max: -978 100123
```


Arrays can be initialized when they are created. The general form for initializing a one-
dimensional array is shown here:
`type[ ] array-name = { val1, val2, ... , valN };`
Java automatically allocates an array large enough to hold the initializers that you specify. There is no need to explicitly use the new operator.
```java
int[] nums = { 99, -10, 100123, 18, -978, 5623, 463, -9, 287, 49 };
```


Array boundaries are strictly enforced in Java; it is a run-time error to overrun or underrun the end of an array.

causing `ArrayIndexOutOfBoundsException`

#### Bubble sort

Logic for Moving each element through comparison and moving smallest element to front

```java
for(a=1; a<size; a++) // loop to traverse
	for(b=size-1; b>= a; b--)
	{
		if(nums[b-1] > nums[b])
		{
			temp = nums[b-1];
			nums[b-1] = nums[b];
			nums[b] = temp;
		}
	}
```

```java
// Bubble sort

class BubbleSort
{
	public static void main(String[] args)
	{
		int[] nums = {99, -10, 100123, 18, -978, 5623, 463, -9, 287, 49 };
		int a, b, temp;
		int size = 10;
		
		System.out.print("Original array: ");
		for(int i=0; i<size; i++)
			System.out.print(" " + nums[i] + " ");
		System.out.println();
		
		for(a=1; a<size; a++)
		{
			for(b=size-1; b>=a; b--)
			{
				if(nums[b-1] > nums[b])
				{
					temp = nums[b-1];
					nums[b-1] = nums[b];
					nums[b] = temp;
				}
			}
		// To print each Iteration
		System.out.print("Sort Iteration " + a + " is : ");
		for(int i=0; i<size; i++)
			System.out.print(" " + nums[i] + " ");
		System.out.println();
		}
	// Final array
	System.out.print("\nSorted Array is : ");
	for(int i=0; i<size; i++)
		System.out.print(" " + nums[i] + " ");
	System.out.println();
	}
}
```


```
$ javac BubbleSort.java 

$ java BubbleSort 
Original array:  99  -10  100123  18  -978  5623  463  -9  287  49 
Sort Iteration 1 is :  -978  99  -10  100123  18  -9  5623  463  49  287 
Sort Iteration 2 is :  -978  -10  99  -9  100123  18  49  5623  463  287 
Sort Iteration 3 is :  -978  -10  -9  99  18  100123  49  287  5623  463 
Sort Iteration 4 is :  -978  -10  -9  18  99  49  100123  287  463  5623 
Sort Iteration 5 is :  -978  -10  -9  18  49  99  287  100123  463  5623 
Sort Iteration 6 is :  -978  -10  -9  18  49  99  287  463  100123  5623 
Sort Iteration 7 is :  -978  -10  -9  18  49  99  287  463  5623  100123 
Sort Iteration 8 is :  -978  -10  -9  18  49  99  287  463  5623  100123 
Sort Iteration 9 is :  -978  -10  -9  18  49  99  287  463  5623  100123 

Sorted Array is :  -978  -10  -9  18  49  99  287  463  5623  100123 
```

___

#### Multidimensional Arrays

In Java, a multidimensional array is an array of arrays.

A two-dimensional array is, in essence, a list of one-dimensional arrays. To declare a two-dimensional integer array
table of size 10, 20 you would write
`int[][] table = new int[10][20];`

```java
// Demonstrate a two-dimensional array.

class TwoD 
{
	public static void main(String[] args) 
	{
		int t, i;
		int[][] table = new int[3][4];
		
		for(t=0; t < 3; ++t) 
		{
			for(i=0; i < 4; ++i) 
			{
				table[t][i] = (t*4)+i+1;
				System.out.print(table[t][i] + " ");
			}
			System.out.println();
		}
	}
}
```

Assigns values from 1 to 12 to all indexes.

___

#### Irregular Arrays

Since multidimensional arrays are implemented as arrays of arrays, the length of each array is under your control.

When you allocate memory for a multidimensional array, you need to specify only the memory
for the first (leftmost) dimension. You can allocate the remaining dimensions separately.

```java
int[][] table = new int[3][];

table[0] = new int[4];
table[1] = new int[2];
table[2] = new int[6];
```

if you
need a very large two-dimensional array that is sparsely populated (that is, one in which not all
of the elements will be used), an irregular array might be a perfect solution.


___

#### Initializing multi dimensional arrays

general form of a multidimensional array declaration:
`type[ ] [ ]...[ ] name = new type[size1][size2]...[sizeN];`

For example, the following declaration creates a 4 × 10 × 3 three-dimensional integer array.
`int[][][] multidim = new int[4][10][3];`


A multidimensional array can be initialized by enclosing each dimension’s initializer list within its own set of curly braces.

```
type-specifier[ ] [ ] array_name = {
	{ val, val, val, ..., val },
	{ val, val, val, ..., val },
	.
	.
	.
	{ val, val, val, ..., val }
};
```

Each inner block designates a row. commas separate the initializer blocks and that a semicolon
follows the closing }.

___

```java
// Initialize a two-dimensional array.
class Squares 
{
	public static void main(String[] args) 
	{
		int[][] sqrs = {
			{ 1, 1 },
			{ 2, 4 },
			{ 3, 9 },
			{ 4, 16 },
			{ 5, 25 },
			{ 6, 36 },
			{ 7, 49 },
			{ 8, 64 },
			{ 9, 81 },
			{ 10, 100 }
		};
		
		int i, j;
		for(i=0; i < 10; i++) 
		{
			for(j=0; j < 2; j++)
				System.out.print(sqrs[i][j] + " ");
			System.out.println();
		}
	}
}
```

#### Alternate Array Declaration

the square brackets follow the name of the array variable, not the type specifier.

The following two declarations are equivalent:
```java
int counter[] = new int[3];
int[] counter = new int[3];


char table[][] = new char[3][4];
char[][] table = new char[3][4];
```


This alternative declaration form offers convenience when converting code from C/C++
to Java. In C/C++, arrays are declared in a fashion similar to Java’s alternative form.

____

#### Assigning Array Reference

when you assign one array reference variable to another, you are simply
changing what object that variable refers to. You are not causing a copy of the array to be
made, nor are you causing the contents of one array to be copied to the other.

___

#### Using length Member

Java, arrays are implemented as objects. One benefit of this approach is that each
array has associated with it a length instance variable that contains the number of elements
that the array can hold. (In other words, length contains the size of the array.)



a two-dimensional array is an array of arrays. Thus, when the expression `table.length` is used, it obtains the number of arrays stored in table, which is 3 in this case. 

To obtain the length of any individual array in table, you will use an expression such as this, `table[0].length`


```java
class LengthDemo
{
	public static void main(String[] args)
	{
		int[] list = new int[10];
		int[] nums = {1,2,3,4};
		int[][] table = {
			{1,2,3},
			{4,5},
			{6,7,8,9}
		};
		
		System.out.println("length of list is " + list.length);
		System.out.println("length of nums is " + nums.length);
	System.out.println("length of table is " + table.length);
	System.out.println("length of table[0] is " + table[0].length);
	System.out.println("length of table[1] is " + table[1].length);
	System.out.println("length of table[2] is " + table[2].length);
	System.out.println();
	
	// Using length to initialize for loop
	for(int i=0; i<list.length; i++)
		list[i] = i*i;
	
	System.out.print("Here is list: ");
	for(int i=0; i<list.length; i++)
		System.out.print(list[i] + " ");
	System.out.println();
	}
}
```

```
length of list is 10
length of nums is 3
length of table is 3
length of table[0] is 3
length of table[1] is 2
length of table[2] is 4

Here is list: 0 1 4 9 16 25 36 49 64 81
```

___

Copying array using length

```java
class ACopy 
{
	public static void main(String[] args) 
	{
		int i;
		int[] nums1 = new int[10];
		int[] nums2 = new int[10];
		
		// Initializing first array
		for(i=0; i < nums1.length; i++)
			nums1[i] = i;
			
		// copy nums1 to nums2
		if(nums2.length >= nums1.length)
			for(i = 0; i < nums1.length; i++)
				nums2[i] = nums1[i];
				
		// printig copied array
		for(i=0; i < nums2.length; i++)
			System.out.print(nums2[i] + " ");
	}
}
```

___

#### Implementing Queue using arrays

```java
class Queue 
{
	char[] q; // this array holds the queue
	int head, tail; // the put and get indices
	
	Queue(int size) 
	{
		q = new char[size]; // allocate memory for queue
		head = tail = 0;
	}
	
	// put a character into the queue
	void put(char ch) 
	{
		if(tail==q.length) 
		{
			System.out.println(" – Queue is full.");
			return;
		}
		q[tail++] = ch;
	}
	
	// get a character from the queue
	char get() 
	{
		if(getloc == putloc) 
		{
			System.out.println(" – Queue is empty.");
			return (char) 0;
		}
		return q[head--];
	}
}
```
Demonstrating operations using the Queue class
```java
class QDemo 
{
	public static void main(String[] args) 
	{
		Queue bigQ = new Queue(100);
		Queue smallQ = new Queue(4);
		char ch;
		int i;
		
		System.out.println("Using bigQ to store the alphabet.");
		// put some numbers into bigQ
		for(i=0; i < 26; i++)
			bigQ.put((char) ('A' + i));
			
		// retrieve and display elements from bigQ
		System.out.print("Contents of bigQ: ");
		for(i=0; i < 26; i++) 
		{
			ch = bigQ.get();
			if(ch != (char) 0) System.out.print(ch);
		}
		System.out.println("\n");
		
		
		
		System.out.println("Using smallQ to generate errors.");
		for(i=0; i < 5; i++) 
		{
			System.out.print("Attempting to store " + (char) ('Z' - i));
			
			smallQ.put((char) ('Z' - i));
			System.out.println();
		}
		System.out.println();
	
		// more errors on smallQ
		System.out.print("Contents of smallQ: ");
		for(i=0; i < 5; i++) 
		{
			ch = smallQ.get();
			if(ch != (char) 0) 
				System.out.print(ch);
		}
	}
}
```

```
Using bigQ to store the alphabet.
Contents of bigQ: ABCDEFGHIJKLMNOPQRSTUVWXYZ

Using smallQ to generate errors.

Attempting to store Z
Attempting to store Y
Attempting to store X
Attempting to store W
Attempting to store V – Queue is full.

Contents of smallQ: ZYXW – Queue is empty.
```

____

#### For-Each Style for Loop

The second form of the for implements a “for-each” style loop. A for-each loop cycles
through a collection of objects, such as an array, in strictly sequential fashion, from start to
finish.

The general form of the for-each style for :

`for(type itr-var : collection) statement-or-block`

type specifies the type, and itr-var specifies the name of an iteration variable that will
receive the elements from a collection, one at a time, from beginning to end. The collection
being cycled through is specified by collection.

With each iteration of the
loop, the next element in the collection is retrieved and stored in itr-var. The loop repeats until
all elements in the collection have been obtained.

Traditional method
```java
int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sum = 0;

for(int i=0; i < 10; i++) 
	sum += nums[i];

// for each loop
for(int x: nums) 
	sum += x;
```

With each pass through the loop, x is automatically given a value equal to the next element in
nums. Thus, on the first iteration, x contains 1, on the second iteration, x contains 2, and so on.
Not only is the syntax streamlined, it also prevents boundary errors.

Although the for-each for loop iterates until all elements in an array have been examined,
it is possible to terminate the loop early by using a break statement. For example, this loop
sums only the first five elements of nums:
```java
// Sum only the first 5 elements.
for(int x : nums) 
{
	System.out.println("Value is: " + x);
	sum += x;
	if(x == 5) break; // stop the loop when 5 is obtained
}
```

___

## Strings

String defines and supports character strings. In some other programming languages,
a string is an array of characters. This is not the case with Java. In Java, strings are objects.
When you create a string literal, you are actually creating a String object.

You can construct a String just like you construct any other type of object: by using new and calling the String constructor. 

`String str = new String("Hello");`

You can also
construct a String from another String. For example:
```
String str = new String("Hello");
String str2 = new String(str);
```

Another easy way to create a String is :
`String str = "Java strings are powerful.";`

```java
// Introduce String.
class StringDemo 
{
	public static void main(String[] args) 
	{
		// declare strings in various ways
		String str1 = new String("Java strings are objects.");
		String str2 = "They are constructed various ways.";
		String str3 = new String(str2);
		
		System.out.println(str1);
		System.out.println(str2);
		System.out.println(str3);
	}
}
```

```
Java strings are objects.
They are constructed various ways.
They are constructed various ways.
```


___

#### Operating on Strings

The String class contains several methods that operate on strings.

`boolean equals(str)`  Returns true if the invoking string contains the same character sequence as str.

`int length( )`  Obtains the length of a string.

`char charAt(index)`  Obtains the character at the index specified by index.

`int compareTo(str)`  Returns less than zero if the invoking string is less than str, greater than zero if the invoking string is greater than str, and zero if the strings are equal.

`int indexOf(str)`  Searches the invoking string for the substring specified by str. Returns the index of the first match or –1 on failure.

`int lastIndexOf(str)`  Searches the invoking string for the substring specified by str. Returns the index of the last match or –1 on failure.

____

```java
// Some String operations.
class StrOps 
{
	public static void main(String[] args) 
	{
		String str1 = "When it comes to Web programming, Java is #1.";
		String str2 = new String(str1);
		String str3 = "Java strings are powerful.";

		int result, idx;
		char ch;

		System.out.println("Length of str1: " + str1.length());

		// display str1, one char at a time.
		for(int i=0; i < str1.length(); i++)
			System.out.print(str1.charAt(i));
		
		System.out.println();

		if(str1.equals(str2))
			System.out.println("str1 equals str2");
		else
			System.out.println("str1 does not equal str2");

		if(str1.equals(str3))
			System.out.println("str1 equals str3");
		else
			System.out.println("str1 does not equal str3");

		result = str1.compareTo(str3);

		if(result == 0)
			System.out.println("str1 and str3 are equal");
		else if(result < 0)
			System.out.println("str1 is less than str3");
		else
			System.out.println("str1 is greater than str3");


		// assign a new string to str2
		str2 = "One Two Three One";
		idx = str2.indexOf("One");
		System.out.println("Index of first occurrence of One: " + idx);
		idx = str2.lastIndexOf("One");
		System.out.println("Index of last occurrence of One: " + idx);
	}
}
```

```
Length of str1: 45
When it comes to Web programming, Java is #1.
str1 equals str2
str1 does not equal str3
str1 is greater than str3
Index of first occurrence of One: 0
Index of last occurrence of One: 14
```


____

You can concatenate (join together) two strings using the + operator. 
```java
String str1 = "One";
String str2 = "Two";
String str3 = "Three";
String str4 = str1 + str2 + str3;
```
initializes str4 with the string "OneTwoThree".


The equals( ) method compares the character sequences of two String objects for equality.
Applying the == to two String references simply determines whether the two references refer to the same object.

___

#### Arrays of strings

```java
// Demonstrate String arrays.
class StringArrays 
{
	public static void main(String[] args) 
	{
		String[] strs = { "This", "is", "a", "test." };
		
		System.out.println("Original array: ");
		for(String s : strs)
			System.out.print(s + " ");
		System.out.println("\n");

		// change a string
		strs[1] = "was";
		strs[3] = "test, too!";
		
		System.out.println("Modified array: ");
		for(String s : strs)
			System.out.print(s + " ");
	}
}
```

```
Original array:
This is a test.

Modified array:
This was a test, too!
```

___

#### Strings are Immutable

The contents of a String object are immutable. That is, once created, the character sequence that makes up the string cannot be altered. 

This restriction allows Java to implement strings more
efficiently.

When you need a string that is a variation on one that already exists, simply create a new string that contains the
desired changes. Unused String objects are automatically garbage collected.

String reference variables may, of course, change the object to which they refer. It is just that the contents of a specific String object cannot be changed after it is created.


The substring( ) method returns a new string that contains
a specified portion of the invoking string. Because a new String object is manufactured that
contains the substring, the original string is unaltered, and the rule of immutability remains
intact. 

`String substring(int startIndex, int endIndex)`

```java
class SubStr
{
	public static void main(String[] args)
	{
		String origStr = "Java makes the web move.";
		
		// Construct a substring
		String substr = origStr.substring(5, 18);
		
		System.out.println("Original : " + origStr);
		System.out.println("SubString : " + substr);
	}
}
```


#### String to Control switch

With a
modern version of Java, you can use a String to control a switch. This results in more readable,
streamlined code in many situations.

```java
class StringSwitch 
{
	public static void main(String[] args) 
	{
		String command = "cancel";
		switch(command) 
		{
			case "connect":
				System.out.println("Connecting");
				break;
			case "cancel":
				System.out.println("Canceling");
				break;
			case "disconnect":
				System.out.println("Disconnecting");
				break;
			default:
				System.out.println("Command Error!");
				break;
		}
	}
}
```

Being able to use strings in a switch statement can be very convenient and can improve
the readability of some code. For example, using a string-based switch is an improvement
over using the equivalent sequence of if/else statements. However, switching on strings can be
less efficient than switching on integers.

___

#### text block 

A text block is a new kind of string literal
that is comprised of a sequence of characters that can occupy more than one line.
newline characters can be used in a text block without the need for the \n escape
sequence. Furthermore, tab and double quote characters can also be entered directly, without
using an escape sequence, and the indentation of a multiline string can be preserved.

```java

String str = """
Text blocks make multiple lines easy because they eliminate
	the need to use \n escape sequences to indicate a newline.
As a result, text blocks make the programmer's life better!
""";

System.out.println(str);
```

```
Text blocks make multiple lines easy because they eliminate
	the need to use \n escape sequences to indicate a newline.
As a result, text blocks make the programmer's life better!
```

____

#### Using Command-Line Arguments

A command-line argument is the information that directly follows the program’s name on the command line when it is executed. they are stored as strings in the String array
passed to main( )

```java
class CLDemo
{
	public static void main(String[] args)
	{
		System.out.println("There are " + args.length + " Command line arguments.");
		
		System.out.println("They are: ");
		for(int i =0; i<args.length; i++)
			System.out.println("args : " + args[i]);
	}
}
```

```
$ java CLDemo one two three
There are 3 Command line arguments.
They are: 
args : one
args : two
args : three
```

`str.length()` is used for String
`str.length` for array of string type

____


#### Type Inference wit local variables

when a variable is initialized, the type of the initializer must be the
same as (or convertible to) the declared type of the variable. Thus, in principle, it would not
be necessary to specify an explicit type for an initialized variable because it could be inferred
from the type of its initializer.

To support local variable
type inference, the context-sensitive keyword var was added to Java.

To use local variable type inference, the variable must be declared with var as the type
name and it must include an initializer.

```java
double avg = 10.0

var avg = 10.0
```
Both will be of type double


var is context-sensitive. When it is used as the type name in the context
of a local variable declaration, it tells the compiler to use type inference to determine the type
of the variable being declared based on the type of the initializer. Thus, in a local variable
declaration, var is a placeholder for the actual inferred type.


```java
var myArray = new int[10];


var[] myArray = new int[10]; // Wrong
var myArray[] = new int[10]; // Wrong

var counter; // Wrong! Initializer required.
```

var can be used only to declare local variables. It cannot be used when
declaring instance variables, parameters, or return types,

```java
var myStr = "This is a string";
var mySubStr = myStr.substring(5, 10);
```

```
FileInputStream fin = new FileInputStream("test.txt");

var fin = new FileInputStream("test.txt");
```

Usage in Initializing object of class
```java
class MyClass
{
	private int i;
	
	MyClass(int k) {
		i = k;
	}
		
	int geti(){
		return i;
	}
		
	void seti(int k)
	{
		if( k >=0)
			i=k;
	}
}

class VarDemo
{
	public static void main(String[] args)
	{
		var mc = new MyClass(10);
		// Type is inferred from initializer
		System.out.println("Value of i in mc is " + mc.geti());
		mc.seti(19);
		System.out.println("Value of i in mc now is " + mc.geti());
	}
}
```

```
Value of i in mc is 10
Value of i in mc now is 19
```

even if only one parameter in method it needs `{ }`

___

var can be used in for and for each loop also
```java
// Use type inference in a for loop.

class VarDemo3 {
public static void main(String[] args) 
{
	// Use type inference with the loop control variable.
	System.out.print("Values of x: ");
	for(var x = 2.5; x < 100.0; x = x * 2)
		System.out.print(x + " ");
		
	System.out.println();
	
	// Use type inference with the iteration variable.
	int[] nums = { 1, 2, 3, 4, 5, 6};
	System.out.print("Values in nums array: ");
	for(var v : nums)
		System.out.print(v + " ");
		
	System.out.println();
	}
}
```

```
Values of x: 2.5 5.0 10.0 20.0 40.0 80.0
Values in nums array: 1 2 3 4 5 6
```


___

#### Some restrictions of var

Only one variable can be declared at a time; 
a variable cannot use null as an initializer; 
and the variable being declared cannot be used by the initializer expression.

ou can declare an array type using var, you cannot use var with an array initializer.
```java
var myArray = new int[10]; // This is valid.

var myArray = { 1, 2, 3 }; // Wrong
```

Local variable type
inference cannot be used to declare the exception type caught by a catch statement. Also,
neither lambda expressions nor method references can be used as initializers.

___

### Bitwise Operators

The bitwise operators can be
used on values of type long, int, short, char, or byte. Bitwise operations cannot be used on
boolean, float, or double, or class types. They are called the bitwise operators because they
are used to test, set, or shift the individual bits that make up a value.

`&  |  ^  ~` are AND, OR, XOR and Negation(Complement)

`<<` shift left 
`>>` shift right
`>>>` Unsigned shift right

```
value << num-bits
value >> num-bits
value >>> num-bits
```

Here, value is the value being shifted by the number of bit positions specified by num-bits.

The bitwise shift operators can be used to perform very fast multiplication or division
by two. A shift left doubles a value. A shift right halves it.

___

#### The ? Operator

The ? operator is often used to replace if-else statements:

The ? is called a ternary operator because it requires three operands. It takes the general form `Exp1 ? Exp2 : Exp3;`

where Exp1 is a boolean expression, and Exp2 and Exp3 are expressions of any type other than
void. The type of Exp2 and Exp3 must be the same (or compatible),

Exp1 is evaluated. If it is true, then
Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then
Exp3 is evaluated and its value becomes the value of the expression

```java
absval = val < 0 ? -val : val; 
// get absolute value of val

// same in if-else
if(val < 0) 
	absval = -val;
else 
	absval = val;
```

____

`result = i != 0 ? 100 / i : 0;` 
result is assigned the outcome of the division of 100 by i. However, this division takes
place only if i is not zero. When i is zero, a placeholder value of zero is assigned to result.

```java
// Prevent a division by zero using the ?.

class NoZeroDiv 
{
	public static void main(String[] args) 
	{
		int result;
		
		for(int i = -5; i < 6; i++) 
		{
			result = i != 0 ? 100 / i : 0;
			// This prevents a divide-by-zero.
			
			if(i != 0)
			System.out.println("100 / " + i + " is " + result);
		}
	}
}
```

```
100 / -5 is -20
100 / -4 is -25
100 / -3 is -33
100 / -2 is -50
100 / -1 is -100
100 / 1 is 100
100 / 2 is 50
100 / 3 is 33
100 / 4 is 25
100 / 5 is 20
```

____


