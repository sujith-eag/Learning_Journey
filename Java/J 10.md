
## Chapter 8 : Packages and Interfaces

Key Skills & Concepts
●Use packages
●Understand how packages affect access
●Apply the protected access modifier
●Import packages
●Know Java’s standard packages
●Understand interface fundamentals
●Implement an interface
●Apply interface references
●Understand interface variables
●Extend interfaces
●Create default, static, and private interface methods

Packages are groups of related classes. Packages help organize your code and provide another layer of encapsulation. Packages also play an important role with modules. 

An interface defines a set of methods that will be implemented by a class. Thus, an interface gives you a way to specify what a class will do, but not how it will do it.

Packages and interfaces give you greater control over the organization of your program.


___

#### Packages

A package serves two purposes. 

First, it provides a mechanism by which related pieces of a program can be organized as a unit. Classes defined
within a package must be accessed through their package name. Thus, a package provides a way to name a collection of classes. 

Second, a package participates in Java’s access control
mechanism. Classes defined within a package can be made private to that package and not accessible by code outside the package. Thus, the package provides a means by which classes can be encapsulated.



when you name a class, you are allocating a name from the namespace.
A namespace defines a declarative region. In Java, no two classes can use the same name
from the same namespace. Thus, within a given namespace, each class name must be
unique. you must avoid name collisions with code created by
other programmers working on the same project, and with Java’s library. The solution to these
problems is the package because it gives you a way to partition the namespace. When a class
is defined within a package, the name of that package is attached to each class, thus avoiding
name collisions with other classes that have the same name, but are in other packages.

Since a package usually contains related classes, Java defines special access rights to code
within a package. In a package, you can define code that is accessible by other code within the
same package but not by code outside the package. This enables you to create self-contained
groups of related classes that keep their operation private.


#### Define a Packeage

All classes in Java belong to some package. When no package statement is specified, the
default package is used. Furthermore, the default package has no name, which makes the default
package transparent.

To create a package, put a package command at the top of a Java source file. The classes declared within that file will then belong to the specified package. Since a package defines a namespace, the names of the classes that you put into the file become part of that package’s namespace.

This is the general form of the package statement:
`package pkg;`

Here, pkg is the name of the package. For example, the following statement creates a package called mypack:
`package mypack;`

Typically, Java uses the file system to manage packages, with each package stored in its
own directory.
the .class files for any classes you declare to be part of mypack must be stored in a directory called mypack.

Like the rest of Java, package names are case sensitive. This means that the directory in
which a package is stored must be precisely the same as the package name. If you have trouble, remember to check your package and directory names carefully. 

Lowercase is often used for package names.
More than one file can include the same package statement. The package statement simply
specifies to which package the classes defined in a file belong. It does not exclude other classes
in other files from being part of that same package. Most real-world packages are spread across
many files.


You can create a hierarchy of packages. To do so, simply separate each package name from
the one above it by use of a period. The general form of a multileveled package statement is
shown here:
`package pack1.pack2.pack3...packN;`

you must create directories that support the package hierarchy that you create.
For example,
package alpha.beta.gamma;
must be stored in .../alpha/beta/gamma, where ... specifies the path to the specified directories.


#### Finding Packages and CLASSPATH


How does the Java run-time system know where to look for packages that you create? 

The answer has three parts. 

First,
by default, the Java run-time system uses the current working directory as its starting
point. Thus, if your package is in a subdirectory of the current directory, it will be found.

Second, you can specify a directory path or paths by setting the CLASSPATH environmental
variable. 

Third, you can use the -classpath option with java and javac to specify the path to
your classes.


beginning with JDK 9, a package can be part of a
module, and thus found on the module path.


The easiest is to simply create the package
directories below your current development directory, put the .class files into the appropriate
directories, and then execute the programs from the development directory.


To avoid problems, it is best to keep all .java and .class files associated with a package in that package’s directory. Also, compile each file from the directory above
the package directory.



Call this file BookDemo.java and put it in a directory called bookpack. Next, compile the file. You can do this by specifying
`javac bookpack/BookDemo.java`
from the directory directly above bookpack. 

BookDemo and Book are now part of the package bookpack. This means that BookDemo cannot be executed by itself. That is, you cannot use this command line:
`java BookDemo`

Instead, BookDemo must be qualified with its package name.:
`java bookpack.BookDemo`



#### Packages and Member Access

The visibility of an element is affected by its access specification—private, public, protected, or default—and the package in which it resides. Thus, as it relates to classes
and packages, the visibility of an element is determined by its visibility within a class and its visibility within a package. This multilayered approach to access control supports a rich
assortment of access privileges.


A private member is accessible only to the other members of its class. A private member is unaffected by its membership in a package. It is only visible witin same class. (one visibility) 


If a member of a class has no explicit access modifier, then it is visible within its package but not outside its package. Therefore, you will use the default access specification for elements that you want to keep private to a package but public within that package.
Visible within same class, same package by subclass and same package by non-sub class (three visibility)


A member specified as protected is accessible within its package and to subclasses in other packages. 
Visible within same class, same package by subclass and same package by non-sub class and also within different packages by subclass (four visibility) 
It is not accessible from different package which is not subclass of protected.

Members explicitly declared public are the most visible, and can be accessed from different classes and different packages by non-subclass also. (five visibility) 




#### Understanding Protected Members



#### Importing Packages

When you use a class from another package, you can fully qualify the name of the class with the
name of its package, such an approach could
easily become tiresome and awkward, especially if the classes you are qualifying are deeply
nested in a package hierarchy.

Using import you
can bring one or more members of a package into view. This allows you to use those members
directly, without explicit package qualification.

`import pkg.classname;`

pkg is the name of the package, which can include its full path, and classname is the name of the class being imported.


If you want to import the entire contents of a package, use
an asterisk `(*)` for the class name.

import mypack.MyClass
import mypack.*;
In the first case, the MyClass class is imported from mypack. In the second, all of the classes in mypack are imported.





#### Java's Class Library in packages

Java defines a large number of standard classes that are
available to all programs. This class library is often referred to as the Java API (Application
Programming Interface). The Java API is stored in packages. At the top of the package hierarchy
is java. Descending from java are several subpackages.

`java.lang` Contains a large number of general-purpose classes
`java.io` Contains I/O classes
`java.net` Contains classes that support networking
`java.util`  Contains a large number of utility classes, including the Collections Framework
`java.awt`  Contains classes that support the Abstract Window Toolkit

java.lang. It contains, among
several others, the System class, which you have been using when performing output using
println( ).

The java.lang package is unique because it is imported automatically into every
Java program. This is why you did not have to import java.lang in the preceding sample
programs. 

However, you must explicitly import the other packages.


#### Interfaces

In object-oriented programming, it is sometimes helpful to define what a class must do but not how it will do it.

An abstract method defines the signature for a method but provides no implementation. A subclass must provide its own implementation of each abstract method defined by its superclass. 
Thus, an abstract method specifies the interface to the method but not the implementation.

In Java, you can
fully separate a class’ interface from its implementation by using the keyword interface.


An interface is syntactically similar to an abstract class, in that you can specify one or
more methods that have no body. Those methods must be implemented by a class in order for
their actions to be defined. Thus, an interface specifies what must be done, but not how to do
it. Once an interface is defined, any number of classes can implement it. Also, one class can
implement any number of interfaces.


To implement an interface, a class must provide bodies (implementations) for the methods
described by the interface. Each class is free to determine the details of its own implementation.
Two classes might implement the same interface in different ways, but each class still
supports the same set of methods. Thus, code that has knowledge of the interface can use objects
of either class since the interface to those objects is the same. By providing the interface keyword,
Java allows you to fully utilize the “one interface, multiple methods” aspect of polymorphism.


Today, it is possible to add a default implementationto an interface method. Furthermore, static interface methods are now supported, and beginning
with JDK 9, an interface can also include private methods. Thus, it is now possible for interface
to specify some behavior.

as a general rule, you
will still often create and use interfaces in which no use is made of these new features.

a simplified general form of a traditional interface:
```java
access interface name {
	ret-type method-name1(param-list);
	ret-type method-name2(param-list);
	type var1 = value;
	type var2 = value;
	// ...
	ret-type method-nameN(param-list);
	type varN = value;
}
```

```java
public interface Series {
int getNext(); // return next number in series
void reset(); // restart
void setStart(int x); // set starting value
}
```
This interface is declared public so that it can be implemented by code in any package.


#### Implementing Interfaces

Once an interface has been defined, one or more classes can implement that interface.
To implement an interface, include the implements clause in a class definition and then
create the methods required by the interface. The general form of a class that includes the
implements clause looks like this:
```
class classname extends superclass implements interface {
	// class-body
}
```

The extends is optional

The methods that implement an interface must be declared public. Also, the type signature
of the implementing method must match exactly the type signature specified in the interface
definition.

Whenever you implement a method defined by an interface, it must
be implemented as public because all members of an interface are implicitly public.

It is both permissible and common for classes that implement interfaces to define
additional members of their own.


If a class includes an interface but does not fully implement the methods
defined by that interface, then that class must be declared abstract. No objects of such
a class can be created, but it can be used as an abstract superclass, allowing subclasses to
provide the complete implementation.




#### Using Interface References



#### Variables in Interfaces

As mentioned, variables can be declared in an interface, but they are implicitly public, static, and
final. At first glance, you might think that there would be very limited use for such variables, but
the opposite is true. Large programs typically make use of several constant values that describe
such things as array size, various limits, special values, and the like. Since a large program is
typically held in a number of separate source files, there needs to be a convenient way to make
these constants available to each file.

To define a set of shared constants, create an interface that contains only these constants,
without any methods. Each file that needs access to the constants simply “implements” the
interface. This brings the constants into view.

```java
// An interface that contains constants.
interface IConst 
{
	int MIN = 0;
	int MAX = 10;
	String ERRORMSG = "Boundary Error";
}
```

```java
class IConstD implements IConst 
{
	public static void main(String[] args) 
	{
		int[] nums = new int[MAX];
		for(int i=MIN; i < 11; i++) 
		{
			if(i >= MAX) 
				System.out.println(ERRORMSG);
			else 
			{
				nums[i] = i;
				System.out.print(nums[i] + " ");
			}
		}
	}
}
```

The technique of using an interface to define shared constants is controversial. It is described here for completeness.


#### Interfaces can be Extended

One interface can inherit another by use of the keyword extends. The syntax is the same as for
inheriting classes. When a class implements an interface that inherits another interface, it must
provide implementations for all methods required by the interface inheritance chain.

any class that implements an interface
must implement all methods required by that interface, including any that are inherited from
other interfaces.


#### Default Interface Methods

A default method
lets you define a default implementation for an interface method. In other words, by use of
a default method, it is possible for an interface method to provide a body, rather than being
abstract. During its development, the default method was also referred to as an extension
method, and you will likely see both terms used.

A primary motivation for the default method was to provide a means by which interfaces
could be expanded without breaking existing code. Recall that there must be implementations
for all methods defined by an interface. In the past, if a new method were added to a popular,
widely used interface, then the addition of that method would break existing code because
no implementation would be found for that method. The default method solves this problem
by supplying an implementation that will be used if no other implementation is explicitly
provided. Thus, the addition of a default method will not cause preexisting code to break.
Another motivation for the default method was the desire to specify methods in an interface
that are, essentially, optional, depending on how the interface is used.

It is important to point out that the addition of default methods does not change a key
aspect of interface: an interface still cannot have instance variables. Thus, the defining
difference between an interface and a class is that a class can maintain state information, but
an interface cannot. Furthermore, it is still not possible to create an instance of an interface
by itself. It must be implemented by a class.


As a general rule, default methods constitute a special-purpose feature.
Interfaces that you create will still be used primarily to specify what and not how. However,
the inclusion of the default method gives you added flexibility.



#### Default Method Fundamentals

An interface default method is defined similar to the way a method is defined by a class. The
primary difference is that the declaration is preceded by the keyword default. For example,
consider this simple interface:
```java
public interface MyIF 
{
	// This is a "normal" interface method declaration.
	// It does NOT define a default implementation.
	int getUserID();
	
// This is a default method with default implementation.
	default int getAdminID() {
	return 1;
	}
}
```

#### Multiple Inheritance issues

default methods do offer a bit of what one would normally
associate with the concept of multiple inheritance. For example, you might have a class that
implements two interfaces. If each of these interfaces provides default methods, then some
behavior is inherited from both. Thus, to a limited extent, default methods do support multiple
inheritance of behavior.

in such a situation, it is possible that a name
conflict will occur.

First, in all cases a class implementation takes priority over an interface default
implementation. The class method overrides the default method.

Second, in cases in which a class inherits two interfaces that both have the same default
method, if the class does not override that method, then an error will result.

In cases in which one interface inherits another, with both defining a common default
method, the inheriting interface’s version of the method takes precedence.

#### Use static methods in an interface

JDK 8 added another new capability to interface: the ability to define one or more static
methods. Like static methods in a class, a static method defined by an interface can be called
independently of any object. Thus, no implementation of the interface is necessary, and no
instance of the interface is required in order to call a static method. Instead, a static method is
called by specifying the interface name, followed by a period, followed by the method name.
Here is the general form:
`InterfaceName.staticMethodName`

```java
public interface MyIF 
{
	// It does NOT define a default implementation.
	int getUserID();

	// a default implementation.
	default int getAdminID() 
	{
		return 1;
	}
	
	// This is a static interface method.
	static int getUniversalID() 
	{
		return 0;
	}
}
```

`int uID = MyIF.getUniversalID();`

no implementation or instance of MyIF is required to call getUniversalID( ) because it is static.

Static interface methods are not inherited by either an implementing class or a subinterface.



#### Private Interface Methods

interface can include a private method. A private interface method
can be called only by a default method or another private method defined by the same
interface. Because a private interface method is specified private, it cannot be used by code
outside the interface in which it is defined. This restriction includes subinterfaces because a
private interface method is not inherited by a subinterface.


The key benefit of a private interface method is that it lets two or more default methods
use a common piece of code, thus avoiding code duplication.


```java
public interface Series 
{
	int getNext(); 
	// return next number in series

	// Return an array that contains the next n elements
	default int[] getNextArray(int n) 
	{
		return getArray(n);
	}

	// Return an array that contains the next n elements
	default int[] skipAndGetNextArray(int skip, int n) 
	{
		// Skip the specified number of elements.
		getArray(skip);
		return getArray(n);
	}

	// A private method that returns an array containing next n elements.
	private int[] getArray(int n) 
	{
		int[] vals = new int[n];
		for(int i=0; i < n; i++) vals[i] = getNext();
		return vals;
	}


	void reset(); // restart
	void setStart(int x); // set starting value
}
```


Notice that both getNextArray( ) and skipAndGetNextArray( ) use the private getArray( )
method to obtain the array to return. This prevents both methods from having to duplicate the
same code sequence. Keep in mind that because getArray( ) is private, it cannot be called by
code outside Series. Thus, its use is limited to the default methods inside Series.
Although the private interface method is a feature that you will seldom need, in those cases
in which you do need it, you will find it quite useful.


____

