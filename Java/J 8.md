
## Chapter 6 : Methods and Classes

Key Skills & Concepts
●Control access to members
●Pass objects to a method
●Return objects from a method
●Overload methods
●Overload constructors
●Use recursion
●Apply static
●Use inner classes
●Use varargs

This chapter resumes our examination of classes and methods. It begins by explaining how to control access to the members of a class. It then discusses the passing and returning of objects, method overloading, recursion, and the use of the keyword static. Also described are nested classes and variable-length arguments.

___

### Controlling access to Class Members

there are two basic types
of class members: public and private. A public member can be freely accessed by code defined
outside of its class. A private member can be accessed only by other methods defined by its
class. It is through the use of private members that access is controlled.

when correctly implemented, a class creates a “black box” that can
be used, but the inner workings of which are not open to tampering.


#### Java Access modifiers

Member access control is achieved through the use of three access modifiers: public, private, and protected. 

If no access modifier is used, the default access setting is assumed as public.


When a member of a class is modified by the public specifier, that member can be accessed by any other code in your program. This includes by methods defined inside other classes.

When a member of a class is specified as private, that member can be accessed only by other members of its class.
methods in other classes cannot access a private member of
another class.

```
public String errMsg;
private accountBalance bal;
private boolean isError(byte status) { // ...
```

```java
// Public vs private access.

class MyClass 
{
	private int alpha; // private access
	public int beta; // public access
	int gamma; // default access


	void setAlpha(int a) {
		alpha = a;
	}

	int getAlpha() {
		return alpha;
	}
}

class AccessDemo
{
	public static void main(String[] args)
	{
		MyClass ob = new MyClass();
		
		ob.setAlpha(-99); // accessor method
		System.out.println("ob.alpha is " + ob.getAlpha());
		
		ob.alpha = 10; // this wont work
		ob.beta = 88; // this is assigned
		ob.gamma = 99; 
	}
}
```

___

#### Pass Objects to Methods

it is correct and common to pass objects to methods.

The sameBlock( ) and sameVolume( ) methods compare the Block object passed as
a parameter to the invoking object. For sameBlock( ), the dimensions of the objects are
compared and true is returned only if the two blocks are the same. For sameVolume( ), the
two blocks are compared only to determine whether they have the same volume. In both cases,
notice that the parameter ob specifies Block as its type. Although Block is a class type created
by the program, it is used in the same way as Java’s built-in types.

```java
class Block 
{
	int a, b, c;
	int volume;
	
	Block(int i, int j, int k) // constructor
	{
		a = i;
		b = j;
		c = k;
		volume = a * b * c;
	}
	
	boolean sameBlock(Block ob) // Object as parameter
	{
		if( (ob.a==a) & (ob.b==b) & (ob.c==c) )
			return true;
		else
			return false;
	}
	
	boolean sameVolume(Block ob)
	{
		if( ob.volume == volume)
			return true;
		else
			return false;
	}
}

class PassOb 
{
	public static void main(String[] args) 
	{
		Block ob1 = new Block(10, 2, 5);
		Block ob2 = new Block(10, 2, 5);
		Block ob3 = new Block(4, 5, 5);
		
	System.out.println("ob1 same dimensions as ob2: " + ob1.sameBlock(ob2));
	
	System.out.println("ob1 same dimensions as ob3: " + ob1.sameBlock(ob3));
	
	System.out.println("ob1 same volume as ob3: " +	ob1.sameVolume(ob3));
	}
}	
```

```
ob1 same dimensions as ob2: true
ob1 same dimensions as ob3: false
ob1 same volume as ob3: true
```

___

#### How Arguments are passed

the effects of passing an object will be different from those experienced when passing non-object arguments.

the two
ways in which an argument can be passed to a subroutine.
The first way is call-by-value. This approach copies the value of an argument into the formal
parameter of the subroutine. Therefore, changes made to the parameter of the subroutine have
no effect on the argument in the call. The second way an argument can be passed is call-by-
reference. In this approach, a reference to an argument (not the value of the argument) is passed
to the parameter. Inside the subroutine, this reference is used to access the actual argument
specified in the call. This means that changes made to the parameter will affect the argument used
to call the subroutine.

When you pass a primitive type, such as int or double, to a method, it is passed by value.

When you pass an object to a method, objects are implicitly passed by reference.

when you create a variable of a class
type, you are creating a reference to an object. It is the reference, not the object itself, that
is actually passed to the method. As a result, when you pass this reference to a method, the
parameter that receives it will refer to the same object as that referred to by the argument.

___

To pass primitive types by reference, Java defines a set of classes that wrap the primitive types in objects.
These are Double, Float, Byte, Short, Integer, Long, and Character. In addition to
allowing a primitive type to be passed by reference, these wrapper classes define several
methods that enable you to manipulate their values.


___

#### Returning Objects

A method can return any type of data, including class types.

```java
class ErrorMsg 
{
	String[] msgs = {
		"Output Error",
		"Input Error",
		"Disk Full",
		"Index Out-Of-Bounds"
		};
	
	String getErrorMsg(int i)
	{
		if(i>= 0 & i<msgs.length)
			return msgs[i];
		else
			return "Invalid Error Code";
	} 
}

class ErrMsg
{
	public static void main(String[] args)
	{
		ErrorMsg err = new ErrorMsg();
		
		System.out.println(err.getErrorMsg(2));
		System.out.println(err.getErrorMsg(19));
	}
}
```

```
Disk Full
Invalid Error Code
```

___

Returning Created Objects
```java
// Return a programmer-defined object.
class Err 
{
	String msg; // error message
	int severity; // code indicating severity of error
	
	Err(String m, int s) 
	{
		msg = m;
		severity = s;
	}
}

class ErrorInfo 
{
	String[] msgs = 
	{
		"Output Error",
		"Input Error",
		"Disk Full",
		"Index Out-Of-Bounds"
	};	
	int[] howBad = { 3, 3, 2, 4 };
	
	Err getErrorInfo(int i) //Return an object of type Err.
	{
		if(i >= 0 & i < msgs.length)
			return new Err(msgs[i], howBad[i]);
		else
			return new Err("Invalid Error Code", 0);
	}
}

class ErrInfo 
{
	public static void main(String[] args) 
	{
		ErrorInfo err = new ErrorInfo();
		Err e;
		e = err.getErrorInfo(2);
		System.out.println(e.msg + " severity: " + e.severity);
	
		e = err.getErrorInfo(19);
		System.out.println(e.msg + " severity: " + e.severity);
	}
}
```

```
Disk Full severity: 2
Invalid Error Code severity: 0
```


Each time getErrorInfo( ) is invoked, a new Err object is created, and a reference to it is
returned to the calling routine. This object is then used within main( ) to display the error
message and severity code.

___

#### Method Overloading

In Java, two or more methods within the same class can share the same name, as long as
their parameter declarations are different. When this is the case, the methods are said to be
overloaded, and the process is referred to as method overloading. Method overloading is one
of the ways that Java implements polymorphism.

to overload a method, simply declare different versions of it.

one important restriction: the type and/or number of
the parameters of each overloaded method must differ. It is not sufficient for two methods
to differ only in their return types. (Return types do not provide sufficient information in all
cases for Java to decide which method to use.) Of course, overloaded methods may differ in
their return types, too. When an overloaded method is called, the version of the method whose
parameters match the arguments is executed.

```java
class Overload
{
	void ovlDemo()
	{
		System.out.println("No Parameters");
	}
	
	void ovlDemo(int a)
	{
		System.out.println("One Parameter: " + a);
	}
	
	int ovlDemo(int a, int b)
	{
		System.out.println("Two parameters: " + a + " " + b);
		return a+b;
	}

	double ovlDemo(double a, double b)
	{
		System.out.println("Two parameters: " + a + " " + b);
		return a+b;
	}
}

class OverloadDemo
{
	public static void main(String[] args)
	{
		Overload ob = new Overload();
		int resI;
		double resD;
		
		ob.ovlDemo();
		
		ob.ovlDemo(2);	
		
		resI = ob.ovlDemo(4,6);
		System.out.println("Result : " + resI);
		
		resD = ob.ovlDemo(1.1, 2.32);
		System.out.println("Result : " + resD);
	}
}
```

```
No parameters

One parameter: 2

Two parameters: 4 6
Result : 10

Two double parameters: 1.1 2.32
Result : 3.42
```

ovlDemo( ) is overloaded four times. The first version takes no parameters, the second takes one integer parameter, the third takes two integer parameters, and the fourth takes
two double parameters.


Return types cannot be used to differentiate overloaded methods.

Method overloading supports polymorphism because it is one way that Java implements
the “one interface, multiple methods” paradigm.

There is no rule stating that overloaded methods must relate to one another. However,
from a stylistic point of view, method overloading implies a relationship. While you can use the same name to overload unrelated methods, you should not.

___

#### Overloading Constructors

Like methods, constructors can also be overloaded. Doing so allows you to construct objects in a variety of ways.

```java
// Overloaded constructor

class MyClass
{
	int x;

	// Variety of Constructors
	MyClass()
	{
		System.out.println("Inside MyClass()");
		x = 0;
	}
	
	MyClass(int i)
	{
		System.out.println("Inside MyClass(int)");
		x = i;
	}
	
	MyClass(double d)
	{
		System.out.println("Inside MyClass(double)");
		x = (int) d;
	}
	
	MyClass(int i, int j)
	{
		System.out.println("Inside MyClass(int, int)");
		x = i*j;
	}
}


class OverloadConsDemo 
{
	public static void main(String[] args) 
	{
		MyClass t1 = new MyClass();
		MyClass t2 = new MyClass(88);
		MyClass t3 = new MyClass(17.23);
		MyClass t4 = new MyClass(2, 4);
		
		System.out.println("t1.x: " + t1.x);
		System.out.println("t2.x: " + t2.x);
		System.out.println("t3.x: " + t3.x);
		System.out.println("t4.x: " + t4.x);
	}
}
```

```
Inside MyClass().
Inside MyClass(int).
Inside MyClass(double).
Inside MyClass(int, int).
t1.x: 0
t2.x: 88
t3.x: 17
t4.x: 8
```

MyClass( ) is overloaded four ways, each constructing an object differently. The proper
constructor is called based upon the parameters specified when new is executed. By overloading
a class’ constructor, you give the user of your class flexibility in the way objects are constructed.

___

One of the most common reasons that constructors are overloaded is to allow one object to initialize another.


```java
// Initialize one object with another.
class Summation 
{
	int sum;
	// Construct from an int.
	Summation(int num) 
	{
		sum = 0;
		for(int i=1; i <= num; i++)
			sum += i;
	}
	
	// Construct from another object.
	Summation(Summation ob) 
	{
		sum = ob.sum;
	}
}

class SumDemo 
{
	public static void main(String[] args) 
	{
		Summation s1 = new Summation(5);
		Summation s2 = new Summation(s1);
		System.out.println("s1.sum: " + s1.sum);
		System.out.println("s2.sum: " + s2.sum);
	}
}
```

```
s1.sum: 15
s2.sum: 15
```

an advantage of providing a constructor that uses one object
to initialize another is efficiency. In this case, when s2 is constructed, it is not necessary to recompute the summation. Of course, even in cases when efficiency is not an issue, it is often useful to provide a constructor that makes a copy of an object.

___

#### Recursion

a method can call itself. This process is called recursion, and a method that calls itself is said to be recursive.

```java
class Factorial
{
	int factR(int n)
	{ // Recursive version
		int result;
		if(n==1) 
			return 1;
			
		result = factR(n-1) * n;
		return result;
	}

	int factI(int n)
	{ // Iterative version
		int t, result;
		result = 1;
		for( t=1; t<= n; t++)
			result *= t;
			
		return result;
	}
}

class Recursion
{
	public static void main(String[] args) 
	{
		Factorial f = new Factorial();
		
		System.out.println("Factorials using recursive method.");
		System.out.println("Factorial of 3 is " + f.factR(3));
		System.out.println("Factorial of 4 is " + f.factR(4));
		System.out.println("Factorial of 5 is " + f.factR(5));
		System.out.println();
		
		System.out.println("Factorials using iterative method.");
		System.out.println("Factorial of 3 is " + f.factI(3));
		System.out.println("Factorial of 4 is " + f.factI(4));
		System.out.println("Factorial of 5 is " + f.factI(5));
		}
}
```

```
Factorials using recursive method.
Factorial of 3 is 6
Factorial of 4 is 24
Factorial of 5 is 120

Factorials using iterative method.
Factorial of 3 is 6
Factorial of 4 is 24
Factorial of 5 is 120
```

___

Recursive versions of many routines may execute a bit more slowly than their iterative
equivalents because of the added overhead of the additional method calls. Too many recursive
calls to a method could cause a stack overrun. Because storage for parameters and local
variables is on the stack and each new call creates a new copy of these variables, it is possible
that the stack could be exhausted.

___

#### Understanding static

When a member is declared static, it can be accessed before any objects of its class are created, and without reference to any object. You can declare both methods and variables to be static.

The most common example of a static member is main( ). 

main( ) is declared as static because it must be called by the JVM when your program begins. Outside the class, to use a static member, you need only specify the name of its class followed by the dot operator. 

No object needs to be created. 

if you want to assign the value 10 to a static variable called
count that is part of the Timer class, use this line:
`Timer.count = 10;`

This format is similar to that used to access normal instance variables through an object, except that the class name is used. A static method can be called in the same way—by use of the dot operator on the name of the class.


Variables declared as static are, essentially, global variables. When an object is declared, no copy of a static variable is made. Instead, all instances of the class share the same static variable.

The difference between a static method and a normal method is that the static method is
called through its class name, without any object of that class being created.

Methods declared as static have several restrictions:
●They can directly call only other static methods in their class.
●They can directly access only static variables in their class.
●They do not have a this reference.

___

#### Static Blocks

Sometimes a class will require some type of initialization before it is ready to create objects. 

For example, it might need to establish a connection to a remote site. It also might need to initialize certain static variables before any of the class’ static methods are used. To handle these types of situations, Java allows you to declare a static block. A static block is executed when the class is first loaded. Thus, it is executed before the class can be used for any other purpose.

```java
// Use a static block

class StaticBlock
{
	static double rootOf2;
	static double rootOf3;

	static { // Executed when class loads
		System.out.println("Inside static block");
		rootOf2 = Math.sqrt(2.0);
		rootOf3 = Math.sqrt(3.0);
	}
	
	StaticBlock(String msg)
	{
		System.out.println(msg);
	}
}

class SDemo3
{
	public static void main(String[] args)
	{
		StaticBlock ob = new StaticBlock("Inside Constructor");
		
		System.out.println("Sqrt of 2 is: " + StaticBlock.rootOf2);
		System.out.println("Sqrt of 3 is: " + StaticBlock.rootOf3);
	} 
}
```

```
Inside static block.
Inside Constructor
Sqrt of 2 is 1.4142135623730951
Sqrt of 3 is 1.7320508075688772
```

the static block is executed before any objects are constructed.

___


#### Quick Sort

The Quicksort is built on the idea of partitions. The general procedure is to select a value,
called the comparand, and then to partition the array into two sections. All elements greater
than or equal to the partition value are put on one side, and those less than the value are put
on the other. This process is then repeated for each remaining section until the array is sorted.

```java
class Quicksort 
{
	// Set up a call to the actual Quicksort method.
	static void qsort(char[] items) 
	{
		qs(items, 0, items.length-1);
	}
	
	// A recursive version of Quicksort for characters.
	private static void qs(char[] items, int left, int right)
	{
		int i, j;
		char x, y;
		i = left; j = right;
		x = items[(left+right)/2];
		do 
		{
			while((items[i] < x) && (i < right)) i++;
			while((x < items[j]) && (j > left)) j--;
			if(i <= j) 
			{
				y = items[i];
				items[i] = items[j];
				items[j] = y;
				i++; j--;
			}
		} while(i <= j);
		
	if(left < j) qs(items, left, j);
	if(i < right) qs(items, i, right);
	}
}

class QSDemo
{
	public static void main(String[] args) 
	{
		char[] a = { 'd', 'x', 'a', 'r', 'p', 'j', 'i' };
		int i;
		System.out.print("Original array: ");
		for(i=0; i < a.length; i++)
			System.out.print(a[i]);
	
		System.out.println();
	
		// now, sort the array
		Quicksort.qsort(a);
		
		System.out.print("Sorted array: ");
		for(i=0; i < a.length; i++)
			System.out.print(a[i]);
	}
}
```

___

#### Nested and Inner Classes

nested class that is declared directly within its
enclosing class scope is a member of its enclosing class. It is also possible to declare a nested
class that is local to a block.

non-static
variety. This type of nested class is also called an inner class. It has access to all of the variables
and methods of its outer class and may refer to them directly in the same way that other non-
static members of the outer class do.


#### Varargs : Variable length arguments

varargs, which is short for
variable-length arguments. A method that takes a variable number of arguments is called a
variable-arity method, or simply a varargs method. The parameter list for a varargs method
is not fixed, but rather variable in length. Thus, a varargs method can take a variable number
of arguments.

A variable-length argument is specified by three periods (...).


```java
static void vaTest(int ... v) 
{
	System.out.println("Number of args: " + v.length);
	System.out.println("Contents: ");
	
		for(int i=0; i < v.length; i++)
			System.out.println(" arg " + i + ": " + v[i]);
	System.out.println();
}
```

`int ... v` This syntax tells the compiler that `vaTest( )` can be called with zero or more arguments. Furthermore, it causes v to be implicitly declared as an array of type `int[ ]`.


A method can have “normal” parameters along with a variable-length parameter. However,
the variable-length parameter must be the last parameter declared by the method. 

`int doIt(int a, int b, double c, int ... vals) {`

there must be only one varargs parameter

___

#### Overloading Vargs Methods

Changing the type of the input parameter to make different version of the methods.

vaTest(int ...) and vaTest(boolean ...).
Remember, the ... causes the parameter to be treated as an array of the specified type. Therefore,
just as you can overload methods by using different types of array parameters, you can overload
varargs methods by using different types of varargs.

The second way to overload a varargs method is to add one or more normal parameters.
This is what was done with vaTest(String, int ...). In this case, Java uses both the number of
arguments and the type of the arguments to determine which method to call.

#### varargs and ambiguity

```java
static void vaTest(int ... v) {

static void vaTest(boolean ... v) {

vaTest(); // causes error
```

vararg parameter can be empty, this call could be translated into a call to vaTest(int ...)
or to vaTest(boolean ...). Both are equally valid. Thus, the call is inherently ambiguous so will not compile.

```java
static void vaTest(int ... v) { // ...

static void vaTest(int n, int ... v) { // ...

vaTest(1);
```
Although the parameter lists of vaTest( ) differ, there is no way for the compiler to resolve the call:


___

