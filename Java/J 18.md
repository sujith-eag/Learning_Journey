
## Chapter 16 : Switch Expressions, Records


Key Skills & Concepts
●Know the features of the expanded switch statement
●Use a list of case constants with switch
●Understand the switch expression
●Use an arrow case with the switch
●Know the fundamentals of record
●Use record canonical constructors
●Use record non-canonical constructors
●Understand how patterns are used with instanceof
●Know the fundamentals of sealed classes and interfaces
●Gain insight into Java’s future directions


A switch expression enables a switch to produce a value. 

Supported by the new keyword record, records enable you to create a new kind of class that is specifically designed to hold a group of values.

A second form of instanceof has been added that uses a type pattern. With this form, you can specify a variable that receives an instance of the type being tested if instanceof succeeds.

It is now possible to specify a sealed class or interface. A sealed class can be inherited by only explicitly specified subclasses. A sealed interface can be implemented by only explicitly specified classes, or extended by only explicitly specified interfaces. Thus, sealing a class or interface gives you detailed control over its inheritance and implementation.

____

#### Enhancements to switch

switch has been
substantially enhanced with the addition of four new features, shown here:
* The switch expression
* The yield statement
* The case with an arrow
* Support for a list of case constants


The switch expression is, essentially, a switch that produces a value. Thus, a switch expression can be used on the right side of an assignment, for example. The yield statement specifies the value that is produced by a switch expression. 

It is now possible to specify more than one case constant in a case statement through the use of a list of case constants. 

A second form of case has been added that uses an arrow (->) instead of a colon. The arrow gives case new capabilities.

A Traditional use of switch case
```java
// obtain the shipping method associated with a product ID.

class TraditionalSwitch 
{
	enum ShipMethod { STANDARD, TRUCK, AIR, OVERNIGHT }

	public static void main(String[] args) 
	{
		ShipMethod shipBy;
		int productID = 5099;

// case stacking is used.
		switch(productID) 
		{
			case 1774:
			case 8708:
			case 6709:
				shipBy = ShipMethod.TRUCK;
				break;
			case 4657:
			case 2195:
			case 3621:
			case 1887:
				shipBy = ShipMethod.AIR;
				break;
			case 2907:
			case 5099:
				shipBy = ShipMethod.OVERNIGHT;
				break;
			default:
				shipBy = ShipMethod.STANDARD;
		}
		System.out.println("Shipping method for product number " +
		productID + " is " + shipBy);
	}
}
```

`Shipping method for product number 5099 is OVERNIGHT`

___

#### Use a List of case Constants

In the past, when two or more constants were both handled by the same code sequence, case stacking was employed.

Although this approach works, a more elegant solution can be achieved by use of a
case constant list. simply separate each constant with a comma.

```java
case 1774, 8708, 6709:
	shipBy = shipMethod.TRUCK;
	break;
```

___


#### Introducing the switch Expression and the yield Statement

A switch expression is, essentially, a switch that returns a value. Thus, it has all of the capabilities of a traditional switch statement, plus the ability to produce a result.

It is very easy to specify a switch expression. Simply use the switch in a context in which a value is required, such as on the right side of an assignment statement, an argument to a method,
or a return value.

```
int result = switch(what) { // ...
```


One way to supply the value of a switch expression is with the yield statement. It has this
general form: `yield value;`

Here, value is the value produced by the switch, and it can be any expression compatible with the type of value required.

A key point to understand about yield is that it immediately terminates the switch. Thus, it works somewhat like break, with the added capability of supplying a value.

yield is a context-sensitive keyword. This means that outside its use in a switch expression, yield is simply an identifier with no special meaning.

___

A key point about using a switch expression is that each case (plus default) must produce a value (unless it throws an exception). In other words, each path through a switch expression must produce a result.

With a traditional switch statement, each case statement must individually assign a value to the variable, and this variable becomes the de facto result of the switch.

```java
class SwitchExprDemo
{
	enum ShipMethod {STANDARD, TRUCK, AIR, OVERNIGHT }
	
	public static void main(String[] args)
	{
		int productID = 5099;
		
		ShipMethod shipBy = switch(productID)
		{
			case 1774, 8708, 6709:
				yield ShipMethod.TRUCK;
			case 4657, 2195, 1887, 3621:
				yield ShipMethod.AIR;
			case 2907, 5099:
				yield ShipMethod.OVERNIGHT;
			default:
				yield ShipMethod.STANDARD;
		};  // semicolon needed
		System.out.println("Shipping method for product number " +
			productID + " is " + shipBy);
	}
}
```
Using a switch expression also ensures that each case yields a value, yield produces a value and causes immediate termination of the switch, so no fall through from case to case will occur.

> [!note]
>  Because this switch is used in an assignment, it must be terminated by a semicolon.

There is an important restriction that applies to a switch expression: the case statements must handle all of the values that might occur.

For this reason, most switch expressions will have a default statement. The exception to this rule is when an enumeration is used, and each value of the enumeration is matched by a case.

____

#### Introducing the Arrow in a case Statement

n easier way to
supply a value is through the use of a new form of the case that substitutes -> for the colon in
a case. For example, this line:
```java
case 'X': // ...

case 'X' -> // ...
```
arrow case and the traditional, colon-based form as a colon case.

Although both forms will match the character X, the precise action of each style of case statement differs in three very important ways.

First, one arrow case does not fall through to the next case. Thus, there is no need to use break. Execution simply terminates at the end of an arrow case.

Second, the arrow case provides a “shorthand” way to supply a value when used in a switch expression. For this reason, the arrow case is often used in switch expressions. 

Third, the target of an arrow case must be either an expression, a block, or throw an exception. It cannot be a statement sequence, as is allowed with a traditional case.

```java
case constant -> expression;

case constant -> { block-of-statements }

case constant -> throw …
```

When the target of an arrow case is an expression, the value of that expression becomes the value of
the switch when that case is matched. As such, it provides a very efficient alternative to the yield statement in many situations.

`case 1774, 8708, 6709 -> ShipMethod.TRUCK;`

value of the expression (which is ShipMethod.TRUCK) automatically becomes
the value produced by the switch when this case is matched. In other words, the expression becomes the value yielded by the switch.

```java
class SwitchExprDemo
{
	enum ShipMethod {STANDARD, TRUCK, AIR, OVERNIGHT }
	
	public static void main(String[] args)
	{
		int productID = 5099;
		
		ShipMethod shipBy = switch(productID)
		{
			// no break or yirld is needed
			case 1774, 8708, 6709 -> ShipMethod.TRUCK;
			case 4657, 2195, 1887, 3621 -> ShipMethod.AIR;
			case 2907, 5099 -> ShipMethod.OVERNIGHT;
			default -> ShipMethod.STANDARD;
		};  // semicolon needed
		System.out.println("Shipping method for product number " +
			productID + " is " + shipBy);
	}
}
```


#### A Closer Look at the Arrow case


the target of the -> can also be a block of code when more than one expression is needed.

Because the target of the arrow is a block, yield must be used to supply the value.

```java
class SwitchExprDemo
{
	enum ShipMethod {STANDARD, TRUCK, AIR, OVERNIGHT }
	
	public static void main(String[] args)
	{
		int productID = 5099;
		boolean extraCharge;
		
		ShipMethod shipBy = switch(productID)
		{
			case 1774, 8708, 6709 ->
			{
				extraCharge = true;
				yield ShipMethod.TRUCK;
			} 
			case 4657, 2195, 1887, 3621 ->
			{
				extraCharge = false;
				yield ShipMethod.AIR;
			}
			case 2907, 5099 -> 
			{
				extraCharge = true;
				yield ShipMethod.OVERNIGHT;
			}
			default -> 
			{
				extraCharge = false;
				yield ShipMethod.STANDARD;
			}
		};  // semicolon needed
		System.out.println("Shipping method for product number " +
			productID + " is " + shipBy);
	}
}
```


when using a block, you must use yield to supply a value to a switch expression. Even though block targets are used, each path through the switch expression must still provide a value.

___

Using in traditional switch where no value is produced but no fall through can occur also.

```java
class StatementSwitchWithArrows 
{
	public static void main(String[] args) 
	{
		// Production line counters.
		int line1count = 0;
		int line2count = 0;
		int line3count = 0;
		
		int productionLine;
		
		for(int i=1; i<10; i++)
		{
			productionLine = (i%3) +1;
			
			switch(productionLine) 
			{
				case 1 -> 
				{ 
					line1count++;
					System.out.println("Line 1 produced a unit.");
				}
				case 2 -> 
				{ 
					line2count++;
					System.out.println("Line 2 produced a unit.");
				}
				case 3 -> 
				{ 
					line1count++;
					System.out.println("Line 3 produced a unit.");
				}
			}
		}
		System.out.println("Total counts for Lines 1, 2, and 3: " + 
			line1count + ", " + line2count + ", " 
				+ line3count);
	}
}
```

If this switch were an expression, then default would be needed because a switch expression is required to be exhaustive.

because each case increases the value of a different variable, it would not be possible to transform this switch into an expression.

> [!Note]
you cannot mix arrow cases with traditional, colon cases in the same switch. You must choose one or the other.


___

Getting time zone using switch
```java
class CityTZDemo 
{
	// Use an enumeration to describe the time zones.
	enum TZ { Eastern, Central, Mountain, Pacific, Other }
	
	public static void main(String[] args) 
	{
		// An array of various cities in North America.
		String[] cities = 
		{
			"New York", "Boston", "Miami", "Chicago",
			"St. Louis", "Des Moines", "Denver",
			"Albuquerque", "Seattle", "San Francisco",
			"Los Angeles", "Portland"
		};
		
		// Display the time zone for each city in the array.
		for(String city: cities) 
		{
			TZ zone = switch(city) 
			{
				case "New York", "Boston", "Miami" -> TZ.Eastern;
				case "Chicago", "St. Louis", "Des Moines" -> TZ.Central;
				case "Albuquerque", "Denver" -> TZ.Mountain;
				case "Seattle", "San Francisco", "Los Angeles", "Portland" -> TZ.Pacific;
				default -> TZ.Other;
			};
			
			if(zone == TZ.Other)
				System.out.println(city + " is outside the Continental US");
			else
				System.out.println(city + " is in the " + zone + " time zone");
		}
	}
}
```

```
New York is in the Eastern time zone
Boston is in the Eastern time zone
Miami is in the Eastern time zone
Chicago is in the Central time zone
St. Louis is in the Central time zone
Des Moines is in the Central time zone
Denver is in the Mountain time zone
Albuquerque is in the Mountain time zone
Seattle is in the Pacific time zone
San Francisco is in the Pacific time zone
Los Angeles is in the Pacific time zone
Portland is in the Pacific time zone
```

____

#### Records



#### Create Record Constructors


#### A Closer Look at Record Getter Methods


#### Pattern Matching with instanceof



#### Sealed Classes and Interfaces



____


