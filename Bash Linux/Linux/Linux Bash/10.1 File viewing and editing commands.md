

___

#### Creating a Text File Using the Nano Editor

To create a text file with the `nano` editor:

```bash {frame="none"}
nano draft.txt  
# Opens nano for editing
```

Type your content, then save using `Ctrl + O` and exit with `Ctrl + X`. 

*Note:* `nano` is a simple text editor suitable for plain text files. 
For more complex editing, consider `Emacs`, `Vim`, or graphical editors like `Gedit` or `VS Code`. On Windows, alternatives include `Notepad++` or `Notepad`.

#### [*touch*](/personal-site/docs/bash-linux/command-docs/touch)

```bash {frame="none"}
touch my_file.txt  
# Creates a blank text file
```

`touch` is mainly for modifying the last access / modification time stamp of a file.
If the file does not exist, an empty text file is created.
`-a` to  modify the last access time and date to current time
`-m` to modify last modification and time and date to current time

`-t` allows to specify new access and modification date and time.
format will be `[[CC]YY]MMDDhhmm[.ss]`


#### [wc](/personal-site/docs/bash-linux/command-docs/wc-word-count)
word count outputs the count of characters (bytes), words (whitespace between characters) , and lines (`\n`) in a text file.
`-c` `-m` limits count to characters
`-l` line count
`-w` word count
They can be combined.
`-L` prints the length of the longest line.

To get the word count for all `.pdb` files in the current directory:

```bash {frame="none"}
$ wc *.pdb
```
Returns the word count of all `.pdb` files individually and also total.


- `wc -l`  # Shows only the number of lines per file.
- `wc -m`  # Shows the number of characters only.
- `wc -w`  # Shows the number of words only.

If `wc -l` is run without specifying a filename, it waits for input from the command prompt. You can exit this mode using `Ctrl + C`.


Command output can be piped to `wc` to count the number of result.
```bash
$ ls -l | wc -l`
```


#### `strings`
This instruction works on files that are not necessarily text files, outputting printable characters found in the file.
```bash
sujith@sujith-Latitude-7490:~/Downloads$ strings sujith.jpeg -n 10
6*&&*6>424>LDDL_Z_||
6*&&*6>424>LDDL_Z_||
Bm&EmvX{2;
!1 0AQ@Paq
```
It outputs any sequence of four or more printable characters found between the unprintable characters.
`-n number` can over ride the length


____

### Text file Viewing Commands

`cat` is one which shows only the last screen worth of data.
`less` and `more` let us step through the file, screen by screen.

#### `more`
it displays a screen's worth of content and pauses. Waits for user to press `<space>` which moves forward by one screen or `<enter>` which moves by one line.
`q` exits to command prompt. Or when end of file is reached.
`-n` is used specify the number of lines that appear in each screen
`+linenumber` to start the display at the given line number.


#### `less`
is more useful as it gives more control to step through the file.
Scrolling is possible with arrow keys. It loads in a `vi`like browser so movement can also by using `vi` commands.
Reaching the end of file will not exit, `q` will exit to command prompt.

#### `head` `tail`
[*head and tail*](/personal-site/docs/bash-linux/command-docs/head-tail)  to view only few lines of the file, not the whole file, `head` and `tail` are used.
By default both display the first ten or last ten lines of a file. 

`-c -n` both expect integer number to follow the option.
`-c` is used to specify the number of bytes (characters) to output.
`-n` specifies the number of lines to output.

for `head` we can precede the integer with a minus sign to indicate that the program should skip that number of bytes or lines.
for `tail`, precede the integer with plus to indicate the starting point within the file.

`head -n -3 file` output all but last three lines of file.
`head -c -20 file` would stop at the 21st byte of the file.
`tail -n 5 file` output last five lines of the file.
`tail -n +12 file` will display the file starting from line 12.


#### [*sort*](/personal-site/docs/bash-linux/command-docs/sort)
The `sort` command sorts lines of text files / output:
Is another file operation to sort line by line in increasing order.
`-r` to sort in decreasing order.
`-f` which causes sort to ignore cases so `a` and `A` are treated equally.
It can work on multiple files in which case the lines are mixed as if the files are combined using `cat`.

```bash {frame="none"}
$ sort lengths.txt  # Sorts alphanumerically by default
sort -n             # Sorts numerically
sort -r             # Sorts in reverse order
```

`$ sort -n lengths.txt` doesn't change the file, but sends results to screen.

To sort and redirect the results to a new file:
```bash {frame="none"}
$ sort -n lengths.txt > sorted-lengths.txt
```


____

### File Comparison Commands

#### `cmp` 
receives two files as parameter and compares them byte by byte, line by line. It stops as soon as it finds a mismatch, returning the byte and line of difference.
`cmp` can be forced to skip over a specified number of bytes for each file or stop after reaching a specified limit. If no mismatch then no output.

`cmp file1 file2 -i 100:150 -n 1024`
compares files one and two, starting at 101 of file 1 and 151 of file 2. Comparing 1024 bytes.

The default counting used with `cmp -i` (`--ignore-initial`) is a value in bytes (characters)


#### `comm`
receives two files which are expected to be sorted.
It might work even if the content is not sorted but will not give proper result.

`comm` instruction works through the two files, comparing line by line and returning each line whether content appeared in the first file, second file or both files.
Output is organized into three columns.
Column 1 has lines appearing only in the first file
Column 2 features lines common to both files.
Column 3 features lines only appearing in the second file.

Options are limited, `-1 -2 -3` which are used to output only lines unique to first file, second file and those in both.

#### `diff`
Can operate on two files, a file and a directory or two directories.
Depending on the type of parameter `diff` works differently.

For two files, compares line by line reporting every mismatch.
The output is somewhat cryptic.
`-i` can be used to make it case insensitive.
`-E` to ignore spacing (tabs)
`-Z` to ignore trailing spaces.
`-b` to ignore difference in white space
`-w` to ignore all white space
`-B` to ignore blank lines.
`-y` to make output into columns

When comparing two directories, `diff` first compares the file names to see if a file exists in one directory which does not exist in another and outputs that. To show some file exist only in one directory.
If there are files with similar names, then `diff` compares them as before.

If comparing a file and directory, it searches for the file name in the directory and compares if found.

`diff` can also compare one file to several other files using `--from-file=` or `--to-file=`


#### `uniq`
It operates on a single file, searching for consecutive duplicate lines.
Parameters can be used to remove duplicate lines.
It does not overwrite the file but the output can be can be moved to a new file.
`uniqu file.txt > filewitoutduplication.txt`

It only compares adjacent lines, it would not find duplicates lines if they do not appear consecutively.



___


### File Manipulation Commands


#### `join`
is used to join two sorted files together when the files contain a common value (field) per line.
When the two files contain a row that contains that same value, then those two lines are joined together. Lines that do not contain a matching first field are not joined.
(Joining tables using a matching keys)

`-1 NUM` and `-2 NUM` allow us to specify which fields should be used on the first and second files respectively where `NUM` is the field number desired. The default is 1.

`-i` causes `join` to ignore case if the common value includes letters.
`-e` uses `STRING` in place of an empty field 
`-a 1` or `-a 2` outputs lines from the first or second file which did not contain a match to the other file.


#### `paste`
is another way of merging files.
The contents of the files are combined line by line. First line is appended to first line of other file.
it is similar to `join` but there is no need for a common field values.


#### `split`
allows to split a file into numerous smaller files.
We specify the file to split and a `prefix` which is name used for new files.

By default `split` will place 1000 bytes in each new file.
`-b value` where value is number of bytes per file.
`-d` causes `split` to a name the new files using digits `00, 01, 02` instead of letters as the extensions to the prefix.


#### `cut`

The `cut` command is used to remove or extract specific sections of each line in a file:

Options are used to indicate which parts of a line to retain, 
based on a number of bytes (`-b first-last`),
specified characters (`-c charlist`)
a deliminator other than tab (`-d 'delimiter'`)
or field numbers (`-f list`) if the line contains individual fields.
Adding `--complement` will reverse the option so that only the cut portion is returned.

```bash {frame="none"}
$ cut -d , -f 2 animals.csv
```
- `-d ,` specifies the delimiter (in this case, a comma).
- `-f` specifies the field (column) to extract.


To get the three (fields)columns of data within a table which are delimited by tab
```bash
cut -f 3,4,6 file
```
if the delimiter was space then it has to specified using `-d ' '`

We can pipe the results of other command to reduce the output.

To remove duplicates from the output, you can pipe `cut` into `sort` and `uniq`:

```bash {frame="none"}
$ cut -d , -f 2 animals.csv | sort | uniq
```
Removing the duplicates using `uniq`
Using `uniq -c` gives the count of occurrences for each line in input.


`ls -l | cut -c 2-10`  outputs only the permissions of the files which starts from 2nd character to 10th.

```bash
sujith@sujith-Latitude-7490:~/Desktop$ ls -l | cut -c 2-10
otal 56
rw-rw-r--
rwxrwxr-x
rw-rw-r--
rwxr-xr-x
rwxr-xr-x
rwxrwxr-x
rwxrwxr-x
rwxrwxr-x
```

 To get the permissions and the file name (getting the first 2-10 chars and also the 9th field where the names are present, with delimiter being space.)
 `ls -l | cut -f 1,9 -d ' '`   won't work properly due to unevenness. 

(`awk` offers better solution that cut for selecting fields)


_____


#### Example Workflow
```bash {frame="none"}
$ cd nart-pacific-gyre
$ wc -l *.txt           # Get the word count of all .txt files
$ wc -l *.txt | sort -n | head -n 5  
# Display the first five line counts

$ wc -l *.txt | sort -n | tail -n 5  
# Display the last five line counts
```

